include "../../../arch/x64/X64.Vale.InsBasic.vaf"
include "../../../arch/x64/X64.Vale.InsMem.vaf"
include "../../../arch/x64/X64.Vale.InsVector.vaf"
include{:fstar}{:open} "Opaque_s"
include{:/*TODO*/fstar}{:open} "FStar.Seq.Base"
include{:fstar}{:open} "Words_s"
include{:fstar}{:open} "Words.Seq_s"
include{:fstar}{:open} "Types_s"
include{:fstar}{:open} "Arch.Types"
include{:fstar}{:open} "AES_s"
include{:fstar}{:open} "GCTR_s"
include{:fstar}{:open} "GCTR"
include{:fstar}{:open} "GCM"
include{:fstar}{:open} "GHash_s"
include{:fstar}{:open} "GHash"
include{:fstar}{:open} "GCM_s"
include{:fstar}{:open} "GF128_s"
include{:fstar}{:open} "GF128"
include{:fstar}{:open} "X64.Poly1305.Math"
include{:fstar}{:open} "GCM_helpers"
include{:fstar}{:open} "X64.Machine_s"
include{:fstar}{:open} "X64.Memory"
include{:fstar}{:open} "X64.Vale.State"
include{:fstar}{:open} "X64.Vale.Decls"
include{:fstar}{:open} "X64.Vale.QuickCode"
include{:fstar}{:open} "X64.Vale.QuickCodes"

module X64.Util

#verbatim{:interface}{:implementation}
open Opaque_s
open FStar.Seq
open Words_s
open Words.Seq_s
open Types_s
open Arch.Types
open AES_s
open GCTR_s
open GCTR
open GCM
open GHash_s
open GHash
open GCM_s
open X64.AES128
open X64.AES256
open X64.AES
open GF128_s
open GF128
open X64.Poly1305.Math
open GCM_helpers
open X64.GHash
open X64.GCTR
open X64.Machine_s
open X64.Memory
open X64.Vale.State
open X64.Vale.Decls
open X64.Vale.InsBasic
open X64.Vale.InsMem
open X64.Vale.InsVector
open X64.Vale.InsAes
open X64.Vale.QuickCode
open X64.Vale.QuickCodes
open X64.GF128_Mul
#endverbatim

#reset-options "--z3rlimit 30"

procedure {:quick}{:exportSpecs}{:public} zero_quad32_stdcall(
    inline win:bool,
    ghost stack_b:buffer64,
    ghost b:buffer128)
    requires
        locs_disjoint(list(loc_buffer(stack_b), loc_buffer(b)));
        buffer_readable(mem, stack_b);
        buffer_readable(mem, b);
        valid_taint_buf64(stack_b, mem, memTaint, Public);
        valid_taint_buf128(b, mem, memTaint, Secret);
        valid_stack_slots(mem, rsp, stack_b, 0, memTaint);
        win ==> rcx == buffer_addr(b, mem);
        !win ==> rdi == buffer_addr(b, mem);

        buffer_length(b) == 1;
    ensures
        modifies_mem(loc_union(loc_buffer(stack_b), loc_buffer(b)), old(mem), mem);
        win ==>  rbx == old(rbx);
        win ==>  rbp == old(rbp);
        win ==>  rdi == old(rdi);
        win ==>  rsi == old(rsi);
        win ==>  rsp == old(rsp);
        win ==>  r12 == old(r12);
        win ==>  r13 == old(r13);
        win ==>  r14 == old(r14);
        win ==>  r15 == old(r15);
        !win ==>  rbx == old(rbx);
        !win ==>  rbp == old(rbp);
        !win ==>  r12 == old(r12);
        !win ==>  r13 == old(r13);
        !win ==>  r14 == old(r14);
        !win ==>  r15 == old(r15);
        win ==>  xmm6 == old(xmm6);
        win ==>  xmm7 == old(xmm7);
        win ==>  xmm8 == old(xmm8);
        win ==>  xmm9 == old(xmm9);
        win ==>  xmm10 == old(xmm10);
        win ==>  xmm11 == old(xmm11);
        win ==>  xmm12 == old(xmm12);
        win ==>  xmm13 == old(xmm13);
        win ==>  xmm14 == old(xmm14);
        win ==>  xmm15 == old(xmm15);

        buffer128_read(b, 0, mem) == Mkfour(0, 0, 0, 0);
    reads memTaint;
    modifies
        rax; rbx; rcx; rdx; rsi; rdi; rbp; rsp; r8; r9; r10; r11; r12; r13; r14; r15;
        xmm0; xmm1; xmm2; xmm3; xmm4; xmm5; xmm6; xmm7; xmm8; xmm9; xmm10; xmm11; xmm12; xmm13; xmm14; xmm15;
        efl; mem;
{
        ZeroXmm(xmm1);
        inline if (win) {
            Store128_buffer(rcx, xmm1, 0, Secret, b, 0);        
        } else {
            Store128_buffer(rdi, xmm1, 0, Secret, b, 0);
        }
}

procedure {:quick}{:exportSpecs}{:public} mk_quad32_lo0_be_1_stdcall(
    inline win:bool,
    ghost stack_b:buffer64,
    ghost b:buffer128)
    requires
        locs_disjoint(list(loc_buffer(stack_b), loc_buffer(b)));
        buffer_readable(mem, stack_b);
        buffer_readable(mem, b);
        valid_taint_buf64(stack_b, mem, memTaint, Public);
        valid_taint_buf128(b, mem, memTaint, Secret);
        valid_stack_slots(mem, rsp, stack_b, 0, memTaint);
        win ==> rcx == buffer_addr(b, mem);
        !win ==> rdi == buffer_addr(b, mem);

        buffer_length(b) == 1;
    ensures
        modifies_mem(loc_union(loc_buffer(stack_b), loc_buffer(b)), old(mem), mem);
        win ==>  rbx == old(rbx);
        win ==>  rbp == old(rbp);
        win ==>  rdi == old(rdi);
        win ==>  rsi == old(rsi);
        win ==>  rsp == old(rsp);
        win ==>  r12 == old(r12);
        win ==>  r13 == old(r13);
        win ==>  r14 == old(r14);
        win ==>  r15 == old(r15);
        !win ==>  rbx == old(rbx);
        !win ==>  rbp == old(rbp);
        !win ==>  r12 == old(r12);
        !win ==>  r13 == old(r13);
        !win ==>  r14 == old(r14);
        !win ==>  r15 == old(r15);
        win ==>  xmm6 == old(xmm6);
        win ==>  xmm7 == old(xmm7);
        win ==>  xmm8 == old(xmm8);
        win ==>  xmm9 == old(xmm9);
        win ==>  xmm10 == old(xmm10);
        win ==>  xmm11 == old(xmm11);
        win ==>  xmm12 == old(xmm12);
        win ==>  xmm13 == old(xmm13);
        win ==>  xmm14 == old(xmm14);
        win ==>  xmm15 == old(xmm15);

        let old_b := buffer128_read(b, 0, old(mem));
        let new_b := buffer128_read(b, 0, mem);
        new_b == Mkfour (1, old_b.lo1, old_b.hi2, old_b.hi3);
    reads memTaint;
    modifies
        rax; rbx; rcx; rdx; rsi; rdi; rbp; rsp; r8; r9; r10; r11; r12; r13; r14; r15;
        xmm0; xmm1; xmm2; xmm3; xmm4; xmm5; xmm6; xmm7; xmm8; xmm9; xmm10; xmm11; xmm12; xmm13; xmm14; xmm15;
        efl; mem;
{
    inline if (win) {
        Load128_buffer(xmm1, rcx, 0, Secret, b, 0);
        PinsrdImm(xmm1, 1, 0, rax);
        Store128_buffer(rcx, xmm1, 0, Secret, b, 0);
    } else {
        Load128_buffer(xmm1, rdi, 0, Secret, b, 0);
        PinsrdImm(xmm1, 1, 0, rax);
        Store128_buffer(rdi, xmm1, 0, Secret, b, 0);
    }
}

procedure {:quick}{:exportSpecs}{:public} quad32_xor_stdcall(
    inline win:bool,
    ghost stack_b:buffer64,
    ghost src1:buffer128,
    ghost src2:buffer128,
    ghost dst:buffer128)
    requires
        locs_disjoint(list(loc_buffer(src1), loc_buffer(src2))) \/ src1 == src2;
        locs_disjoint(list(loc_buffer(src1), loc_buffer(dst))) \/ src1 == dst;
        locs_disjoint(list(loc_buffer(src2), loc_buffer(dst))) \/ src2 == dst;
        locs_disjoint(list(loc_buffer(stack_b), loc_buffer(src1)));
        locs_disjoint(list(loc_buffer(stack_b), loc_buffer(src2)));
        locs_disjoint(list(loc_buffer(stack_b), loc_buffer(dst)));
        buffer_readable(mem, stack_b);
        buffer_readable(mem, src1);
        buffer_readable(mem, src2);
        buffer_readable(mem, dst);
        valid_taint_buf64(stack_b, mem, memTaint, Public);
        valid_taint_buf128(src1, mem, memTaint, Secret);
        valid_taint_buf128(src2, mem, memTaint, Secret);
        valid_taint_buf128(dst, mem, memTaint, Secret);
        valid_stack_slots(mem, rsp, stack_b, 0, memTaint);
        win ==> rcx == buffer_addr(src1, mem);
        win ==> rdx == buffer_addr(src2, mem);
        win ==> r8 == buffer_addr(dst, mem);
        !win ==> rdi == buffer_addr(src1, mem);
        !win ==> rsi == buffer_addr(src2, mem);
        !win ==> rdx == buffer_addr(dst, mem);

        buffer_length(src1) == 1;
        buffer_length(src2) == 1;
        buffer_length(dst) == 1; 
    ensures
        modifies_mem(loc_union(loc_buffer(stack_b), loc_buffer(dst)), old(mem), mem);
        win ==>  rbx == old(rbx);
        win ==>  rbp == old(rbp);
        win ==>  rdi == old(rdi);
        win ==>  rsi == old(rsi);
        win ==>  rsp == old(rsp);
        win ==>  r12 == old(r12);
        win ==>  r13 == old(r13);
        win ==>  r14 == old(r14);
        win ==>  r15 == old(r15);
        !win ==>  rbx == old(rbx);
        !win ==>  rbp == old(rbp);
        !win ==>  r12 == old(r12);
        !win ==>  r13 == old(r13);
        !win ==>  r14 == old(r14);
        !win ==>  r15 == old(r15);
        win ==>  xmm6 == old(xmm6);
        win ==>  xmm7 == old(xmm7);
        win ==>  xmm8 == old(xmm8);
        win ==>  xmm9 == old(xmm9);
        win ==>  xmm10 == old(xmm10);
        win ==>  xmm11 == old(xmm11);
        win ==>  xmm12 == old(xmm12);
        win ==>  xmm13 == old(xmm13);
        win ==>  xmm14 == old(xmm14);
        win ==>  xmm15 == old(xmm15);

        buffer128_read(dst, 0, mem) == quad32_xor(buffer128_read(src1, 0, old(mem)), buffer128_read(src2, 0, old(mem)));
    reads memTaint;
    modifies
        rax; rbx; rcx; rdx; rsi; rdi; rbp; rsp; r8; r9; r10; r11; r12; r13; r14; r15;
        xmm0; xmm1; xmm2; xmm3; xmm4; xmm5; xmm6; xmm7; xmm8; xmm9; xmm10; xmm11; xmm12; xmm13; xmm14; xmm15;
        efl; mem;
{
    inline if (win) {
        Load128_buffer(xmm1, rcx, 0, Secret, src1, 0);
        Load128_buffer(xmm2, rdx, 0, Secret, src2, 0);
        Pxor(xmm1, xmm2);
        Store128_buffer(r8, xmm1, 0, Secret, dst, 0);
    } else {
        Load128_buffer(xmm1, rdi, 0, Secret, src1, 0);
        Load128_buffer(xmm2, rsi, 0, Secret, src2, 0);
        Pxor(xmm1, xmm2);
        Store128_buffer(rdx, xmm1, 0, Secret, dst, 0);      
    }
}

procedure {:quick}{:exportSpecs}{:public} gcm_load_xor_stdcall(
    inline win:bool,
    ghost stack_b:buffer64,
    ghost plain_b:buffer128,
    ghost mask_b:buffer128,
    ghost cipher_b:buffer128,
    ghost offset:nat64,
    ghost num_blocks:nat64,
    ghost key:seq(nat32),
    ghost iv:quad32)
    requires
        locs_disjoint(list(loc_buffer(plain_b), loc_buffer(mask_b)));
        locs_disjoint(list(loc_buffer(plain_b), loc_buffer(cipher_b)));
        locs_disjoint(list(loc_buffer(mask_b), loc_buffer(cipher_b)));
        locs_disjoint(list(loc_buffer(stack_b), loc_buffer(plain_b)));
        locs_disjoint(list(loc_buffer(stack_b), loc_buffer(mask_b)));
        locs_disjoint(list(loc_buffer(stack_b), loc_buffer(cipher_b)));
        buffer_readable(mem, stack_b);
        buffer_readable(mem, plain_b);
        buffer_readable(mem, mask_b);
        buffer_readable(mem, cipher_b);
        valid_taint_buf64(stack_b, mem, memTaint, Public);
        valid_taint_buf128(plain_b, mem, memTaint, Secret);
        valid_taint_buf128(mask_b, mem, memTaint, Secret);
        valid_taint_buf128(cipher_b, mem, memTaint, Secret);
        valid_stack_slots(mem, rsp, stack_b, 0, memTaint);
        win ==> rcx == buffer_addr(plain_b, mem);
        win ==> rdx == buffer_addr(mask_b, mem);
        win ==> r8 == buffer_addr(cipher_b, mem);
        win ==> r9 == offset;
        !win ==> rdi == buffer_addr(plain_b, mem);
        !win ==> rsi == buffer_addr(mask_b, mem);
        !win ==> rdx == buffer_addr(cipher_b, mem);
        !win ==> rcx == offset;

        buffer_length(plain_b) >= num_blocks;
        buffer_length(cipher_b) == buffer_length(plain_b);
        buffer_length(mask_b) == 1;

        is_aes_key_LE(AES_128, key);
        let mask := buffer128_read(mask_b, 0, mem);
        let plain := buffer128_as_seq(mem, plain_b);
        let cipher := buffer128_as_seq(mem, cipher_b);
        offset < num_blocks;
        buffer_addr(plain_b, mem) + offset * 16 < pow2_64;
        buffer_addr(cipher_b, mem) + offset * 16 < pow2_64;
        mask == aes_encrypt_BE(AES_128, key, inc32(iv, offset));
        gctr_partial(AES_128, offset, plain, cipher, key, iv);
    ensures
        modifies_mem(loc_union(loc_buffer(stack_b), loc_buffer(cipher_b)), old(mem), mem);
        win ==>  rbx == old(rbx);
        win ==>  rbp == old(rbp);
        win ==>  rdi == old(rdi);
        win ==>  rsi == old(rsi);
        win ==>  rsp == old(rsp);
        win ==>  r12 == old(r12);
        win ==>  r13 == old(r13);
        win ==>  r14 == old(r14);
        win ==>  r15 == old(r15);
        !win ==>  rbx == old(rbx);
        !win ==>  rbp == old(rbp);
        !win ==>  r12 == old(r12);
        !win ==>  r13 == old(r13);
        !win ==>  r14 == old(r14);
        !win ==>  r15 == old(r15);
        win ==>  xmm6 == old(xmm6);
        win ==>  xmm7 == old(xmm7);
        win ==>  xmm8 == old(xmm8);
        win ==>  xmm9 == old(xmm9);
        win ==>  xmm10 == old(xmm10);
        win ==>  xmm11 == old(xmm11);
        win ==>  xmm12 == old(xmm12);
        win ==>  xmm13 == old(xmm13);
        win ==>  xmm14 == old(xmm14);
        win ==>  xmm15 == old(xmm15);

        let mask := buffer128_read(mask_b, 0, old(mem));
        let plain := buffer128_as_seq(mem, plain_b);
        let old_cipher := buffer128_as_seq(old(mem), cipher_b);
        let cipher := buffer128_as_seq(mem, cipher_b);
        gctr_partial(AES_128, offset + 1, plain, cipher, key, iv);
        slice(cipher, 0, offset) == slice(old_cipher, 0, offset);
    reads memTaint;
    modifies
        rax; rbx; rcx; rdx; rsi; rdi; rbp; rsp; r8; r9; r10; r11; r12; r13; r14; r15;
        xmm0; xmm1; xmm2; xmm3; xmm4; xmm5; xmm6; xmm7; xmm8; xmm9; xmm10; xmm11; xmm12; xmm13; xmm14; xmm15;
        efl; mem;
{
    inline if (win) {
        IMul64(r9, 16);
        Add64(rcx, r9);
        Load128_buffer(xmm2, rcx, 0, Secret, plain_b, offset);
        Load128_buffer(xmm0, rdx, 0, Secret, mask_b, 0);
        Pxor(xmm2, xmm0);
        Add64(r8, r9);
        Store128_buffer(r8, xmm2, 0, Secret, cipher_b, offset);
    } else {
        IMul64(rcx, 16);
        Add64(rdi, rcx);
        Load128_buffer(xmm2, rdi, 0, Secret, plain_b, offset);
        Load128_buffer(xmm0, rsi, 0, Secret, mask_b, 0);
        Pxor(xmm2, xmm0);
        Add64(rdx, rcx);
        Store128_buffer(rdx, xmm2, 0, Secret, cipher_b, offset);
    }
}


procedure {:quick}{:exportSpecs}{:public} reverse_quad32_stdcall(
    inline win:bool,
    ghost stack_b:buffer64,
    ghost b:buffer128)
    requires
        locs_disjoint(list(loc_buffer(stack_b), loc_buffer(b)));
        buffer_readable(mem, stack_b);
        buffer_readable(mem, b);
        valid_taint_buf64(stack_b, mem, memTaint, Public);
        valid_taint_buf128(b, mem, memTaint, Secret);
        valid_stack_slots(mem, rsp, stack_b, 0, memTaint);
        win ==> rcx == buffer_addr(b, mem);
        !win ==> rdi == buffer_addr(b, mem);

        buffer_length(b) == 1;
    ensures
        modifies_mem(loc_union(loc_buffer(stack_b), loc_buffer(b)), old(mem), mem);
        win ==>  rbx == old(rbx);
        win ==>  rbp == old(rbp);
        win ==>  rdi == old(rdi);
        win ==>  rsi == old(rsi);
        win ==>  rsp == old(rsp);
        win ==>  r12 == old(r12);
        win ==>  r13 == old(r13);
        win ==>  r14 == old(r14);
        win ==>  r15 == old(r15);
        !win ==>  rbx == old(rbx);
        !win ==>  rbp == old(rbp);
        !win ==>  r12 == old(r12);
        !win ==>  r13 == old(r13);
        !win ==>  r14 == old(r14);
        !win ==>  r15 == old(r15);
        win ==>  xmm6 == old(xmm6);
        win ==>  xmm7 == old(xmm7);
        win ==>  xmm8 == old(xmm8);
        win ==>  xmm9 == old(xmm9);
        win ==>  xmm10 == old(xmm10);
        win ==>  xmm11 == old(xmm11);
        win ==>  xmm12 == old(xmm12);
        win ==>  xmm13 == old(xmm13);
        win ==>  xmm14 == old(xmm14);
        win ==>  xmm15 == old(xmm15);

        buffer128_read(b, 0, mem) == reverse_bytes_quad32(buffer128_read(b, 0, old(mem)));
    reads memTaint;
    modifies
        rax; rbx; rcx; rdx; rsi; rdi; rbp; rsp; r8; r9; r10; r11; r12; r13; r14; r15;
        xmm0; xmm1; xmm2; xmm3; xmm4; xmm5; xmm6; xmm7; xmm8; xmm9; xmm10; xmm11; xmm12; xmm13; xmm14; xmm15;
        efl; mem;
{
    inline if (win) {
        Load128_buffer(xmm0, rcx, 0, Secret, b, 0);
        InitPshufbMask(xmm1, rax);
        Pshufb(xmm0, xmm1);
        Store128_buffer(rcx, xmm0, 0, Secret, b, 0);
    } else {
        Load128_buffer(xmm0, rdi, 0, Secret, b, 0);
        InitPshufbMask(xmm1, rax);
        Pshufb(xmm0, xmm1);
        Store128_buffer(rdi, xmm0, 0, Secret, b, 0);
    }
}
