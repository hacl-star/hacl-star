include "../../../../arch/x64/X64.Vale.InsBasic.vaf"
include "../../../../arch/x64/X64.Vale.InsMem.vaf"
include "../../../../arch/x64/X64.Vale.InsVector.vaf"
include "../../../../lib/util/x64/X64.Stack.vaf"
include "../X64.AES.vaf"
include "../X64.AES128.vaf"
include "../X64.AES256.vaf"
include{:fstar}{:open} "Types_s"
include{:/*TODO*/fstar}{:open} "FStar.Seq.Base"
include{:fstar}{:open} "AES_s"
include{:fstar}{:open} "X64.Machine_s"
include{:fstar}{:open} "X64.Memory"
include{:fstar}{:open} "X64.Vale.State"
include{:fstar}{:open} "X64.Vale.Decls"
include{:fstar}{:open} "X64.Vale.QuickCode"
include{:fstar}{:open} "X64.Vale.QuickCodes"
include{:fstar}{:open} "Arch.Types"
include{:fstar}{:open} "AES256_helpers"
include{:fstar}{:open} "Opaque_s"
include{:fstar}{:open} "GCTR"
include{:fstar}{:open} "X64.CPU_Features_s"

module X64.AESstdcall

#verbatim{:interface}{:implementation}
open Types_s
open FStar.Seq
open AES_s
open X64.Machine_s
open X64.Memory
open X64.Vale.State
open X64.Vale.Decls
open X64.Vale.InsBasic
//open X64.Vale.InsMem
open X64.Vale.InsVector
//open X64.Vale.InsAes
open X64.Vale.QuickCode
open X64.Vale.QuickCodes
open Arch.Types
//open AES_helpers
open AES256_helpers
open Opaque_s
open X64.AES128
open X64.AES256
open GCTR
open X64.CPU_Features_s
open X64.Stack
#endverbatim

#reset-options "--z3rlimit 20"

procedure {:quick}{:exportSpecs}{:public} AESEncryptBlockStdcall(
    inline win:bool,
    ghost stack_b:buffer64,
    ghost output_b:buffer128,
    ghost input_b:buffer128,
    ghost key:seq(nat32),
    ghost keys_b:buffer128)
    lets
        output_ptr := if win then rcx else rdi;
        input_ptr := if win then rdx else rsi;
        expanded_key_ptr := if win then r8 else rdx;    
    requires
        locs_disjoint(list(loc_buffer(output_b), loc_buffer(input_b))) \/ output_b == input_b;
        locs_disjoint(list(loc_buffer(output_b), loc_buffer(keys_b))) \/ output_b == keys_b;
        locs_disjoint(list(loc_buffer(input_b), loc_buffer(keys_b))) \/ input_b == keys_b;
        locs_disjoint(list(loc_buffer(stack_b), loc_buffer(output_b)));
        locs_disjoint(list(loc_buffer(stack_b), loc_buffer(input_b)));
        locs_disjoint(list(loc_buffer(stack_b), loc_buffer(keys_b)));
        buffer_readable(mem, stack_b);
        buffer_readable(mem, output_b);
        buffer_readable(mem, input_b);
        buffer_readable(mem, keys_b);
        valid_taint_buf64(stack_b, mem, memTaint, Public);
        valid_taint_buf128(output_b, mem, memTaint, Secret);
        valid_taint_buf128(input_b, mem, memTaint, Secret);
        valid_taint_buf128(keys_b, mem, memTaint, Secret);
        valid_stack_slots(mem, rsp, stack_b, if win then 28 else 8, memTaint);
        win ==> rcx == buffer_addr(output_b, mem);
        win ==> rdx == buffer_addr(input_b, mem);
        win ==> r8 == buffer_addr(keys_b, mem);
        !win ==> rdi == buffer_addr(output_b, mem);
        !win ==> rsi == buffer_addr(input_b, mem);
        !win ==> rdx == buffer_addr(keys_b, mem);

        aesni_enabled;
        is_aes_key_LE(AES_128, key);
        expanded_key_ptr == buffer_addr(keys_b, mem);
        validSrcAddrs128(mem, input_ptr, input_b, 1, memTaint, Secret);
        validSrcAddrs128(mem, output_ptr, output_b, 1, memTaint, Secret);
        validSrcAddrs128(mem, expanded_key_ptr, keys_b, nr(AES_128) + 1, memTaint, Secret);
        forall i:nat :: i < nr(AES_128) + 1 ==>
            buffer128_read(keys_b, i, mem) == index(key_to_round_keys_LE(AES_128, key), i);
    ensures
        modifies_mem(loc_union(loc_buffer(stack_b), loc_buffer(output_b)), old(mem), mem);
        win ==>  rbx == old(rbx);
        win ==>  rbp == old(rbp);
        win ==>  rdi == old(rdi);
        win ==>  rsi == old(rsi);
        win ==>  rsp == old(rsp);
        win ==>  r12 == old(r12);
        win ==>  r13 == old(r13);
        win ==>  r14 == old(r14);
        win ==>  r15 == old(r15);
        !win ==>  rbx == old(rbx);
        !win ==>  rbp == old(rbp);
        !win ==>  r12 == old(r12);
        !win ==>  r13 == old(r13);
        !win ==>  r14 == old(r14);
        !win ==>  r15 == old(r15);
        win ==>  xmm6 == old(xmm6);
        win ==>  xmm7 == old(xmm7);
        win ==>  xmm8 == old(xmm8);
        win ==>  xmm9 == old(xmm9);
        win ==>  xmm10 == old(xmm10);
        win ==>  xmm11 == old(xmm11);
        win ==>  xmm12 == old(xmm12);
        win ==>  xmm13 == old(xmm13);
        win ==>  xmm14 == old(xmm14);
        win ==>  xmm15 == old(xmm15);

        validSrcAddrs128(mem, output_ptr, output_b, 1, memTaint, Secret);
        buffer128_read(output_b, 0, mem) == aes_encrypt_LE(AES_128, key, buffer128_read(input_b, 0, old(mem)));
    reads memTaint;
    modifies
        rax; rbx; rcx; rdx; rsi; rdi; rbp; rsp; r8; r9; r10; r11; r12; r13; r14; r15;
        xmm0; xmm1; xmm2; xmm3; xmm4; xmm5; xmm6; xmm7; xmm8; xmm9; xmm10; xmm11; xmm12; xmm13; xmm14; xmm15;
        efl; mem;
{
    callee_save_registers(win, stack_b);

    AES128EncryptBlockStdcall(win, buffer128_read(input_b, 0, old(mem)), key, input_b, output_b, keys_b);

    callee_restore_registers(win, stack_b, old(xmm6), old(xmm7), old(xmm8),
        old(xmm9), old(xmm10), old(xmm11), old(xmm12), old(xmm13), old(xmm14), old(xmm15));
}

procedure {:quick}{:exportSpecs}{:public} aes_EncryptBlockBEStdcall(
    inline win:bool,
    ghost stack_b:buffer64,
    ghost output_b:buffer128,
    ghost input_b:buffer128,
    ghost key:seq(nat32),
    ghost keys_b:buffer128)
    lets
        output_ptr := if win then rcx else rdi;
        input_ptr := if win then rdx else rsi;
        expanded_key_ptr := if win then r8 else rdx;    
    requires
        locs_disjoint(list(loc_buffer(output_b), loc_buffer(input_b))) \/ output_b == input_b;
        locs_disjoint(list(loc_buffer(output_b), loc_buffer(keys_b))) \/ output_b == keys_b;
        locs_disjoint(list(loc_buffer(input_b), loc_buffer(keys_b))) \/ input_b == keys_b;
        locs_disjoint(list(loc_buffer(stack_b), loc_buffer(output_b)));
        locs_disjoint(list(loc_buffer(stack_b), loc_buffer(input_b)));
        locs_disjoint(list(loc_buffer(stack_b), loc_buffer(keys_b)));
        buffer_readable(mem, stack_b);
        buffer_readable(mem, output_b);
        buffer_readable(mem, input_b);
        buffer_readable(mem, keys_b);
        valid_taint_buf64(stack_b, mem, memTaint, Public);
        valid_taint_buf128(output_b, mem, memTaint, Secret);
        valid_taint_buf128(input_b, mem, memTaint, Secret);
        valid_taint_buf128(keys_b, mem, memTaint, Secret);
        valid_stack_slots(mem, rsp, stack_b, if win then 28 else 8, memTaint);
        win ==> rcx == buffer_addr(output_b, mem);
        win ==> rdx == buffer_addr(input_b, mem);
        win ==> r8 == buffer_addr(keys_b, mem);
        !win ==> rdi == buffer_addr(output_b, mem);
        !win ==> rsi == buffer_addr(input_b, mem);
        !win ==> rdx == buffer_addr(keys_b, mem);

        aesni_enabled;
        locs_disjoint(list(loc_buffer(input_b), loc_buffer(keys_b)));
        locs_disjoint(list(loc_buffer(output_b), loc_buffer(keys_b)));
        buffers_disjoint128(output_b, input_b) \/ output_b == input_b;
        is_aes_key_LE(AES_128, key);
        expanded_key_ptr == buffer_addr(keys_b, mem);
        validSrcAddrs128(mem, input_ptr, input_b, 1, memTaint, Secret);
        validSrcAddrs128(mem, output_ptr, output_b, 1, memTaint, Secret);
        validSrcAddrs128(mem, expanded_key_ptr, keys_b, nr(AES_128) + 1, memTaint, Secret);
        forall i:nat :: i < nr(AES_128) + 1 ==>
            buffer128_read(keys_b, i, mem) == index(key_to_round_keys_LE(AES_128, key), i);
    ensures
        modifies_mem(loc_union(loc_buffer(stack_b), loc_buffer(output_b)), old(mem), mem);
        win ==>  rbx == old(rbx);
        win ==>  rbp == old(rbp);
        win ==>  rdi == old(rdi);
        win ==>  rsi == old(rsi);
        win ==>  rsp == old(rsp);
        win ==>  r12 == old(r12);
        win ==>  r13 == old(r13);
        win ==>  r14 == old(r14);
        win ==>  r15 == old(r15);
        !win ==>  rbx == old(rbx);
        !win ==>  rbp == old(rbp);
        !win ==>  r12 == old(r12);
        !win ==>  r13 == old(r13);
        !win ==>  r14 == old(r14);
        !win ==>  r15 == old(r15);
        win ==>  xmm6 == old(xmm6);
        win ==>  xmm7 == old(xmm7);
        win ==>  xmm8 == old(xmm8);
        win ==>  xmm9 == old(xmm9);
        win ==>  xmm10 == old(xmm10);
        win ==>  xmm11 == old(xmm11);
        win ==>  xmm12 == old(xmm12);
        win ==>  xmm13 == old(xmm13);
        win ==>  xmm14 == old(xmm14);
        win ==>  xmm15 == old(xmm15);

        validSrcAddrs128(mem, output_ptr, output_b, 1, memTaint, Secret);
        buffer128_read(output_b, 0, mem) == aes_encrypt_BE(AES_128, key, buffer128_read(input_b, 0, old(mem)));
    reads memTaint;
    modifies
        rax; rbx; rcx; rdx; rsi; rdi; rbp; rsp; r8; r9; r10; r11; r12; r13; r14; r15;
        xmm0; xmm1; xmm2; xmm3; xmm4; xmm5; xmm6; xmm7; xmm8; xmm9; xmm10; xmm11; xmm12; xmm13; xmm14; xmm15;
        efl; mem;
{
    callee_save_registers(win, stack_b);

    // Reverse the input
    InitPshufbMask(xmm2, rax);
    inline if (win) {
        Load128_buffer(xmm0, rdx, 0, Secret, input_b, 0);
        Pshufb(xmm0, xmm2);
    } else {
        Load128_buffer(xmm0, rsi, 0, Secret, input_b, 0);
        Pshufb(xmm0, xmm2);
        Mov64(r8, rdx);
    }

    assert {:quick_type} is_aes_key_LE(AES_128, key);
    AES128EncryptBlock(reverse_bytes_quad32(buffer128_read(input_b, 0, old(mem))), key, key_to_round_keys_LE(AES_128, key), keys_b);

    inline if (win)
    {
        Store128_buffer(rcx, xmm0, 0, Secret, output_b, 0);
    }
    else
    {
        Store128_buffer(rdi, xmm0, 0, Secret, output_b, 0);
    }
    reveal aes_encrypt_LE_def;

    callee_restore_registers(win, stack_b, old(xmm6), old(xmm7), old(xmm8),
        old(xmm9), old(xmm10), old(xmm11), old(xmm12), old(xmm13), old(xmm14), old(xmm15));
}