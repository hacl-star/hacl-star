include "X64.Vale.InsBasic.vaf"
include "X64.Vale.InsVector.vaf"
include{:fstar}{:open} "Words_s"
include{:fstar}{:open} "Types_s"
include{:fstar}{:open} "Arch.Types"
include{:fstar}{:open} "Spec.SHA2"
include{:fstar}{:open} "SHA_helpers"
include{:fstar}{:open} "Spec.Hash.PadFinish"
include{:fstar}{:open} "X64.Machine_s"
include{:fstar}{:open} "X64.Vale.State"
include{:fstar}{:open} "X64.Vale.Decls"
include{:fstar}{:open} "X64.Vale.QuickCode"
include{:fstar}{:open} "X64.CPU_Features_s"

module X64.Vale.InsSha

#verbatim{:interface}
open Words_s
open Types_s
open Arch.Types
open Spec.Hash.PadFinish
open Spec.SHA2
open Spec.Hash.Definitions
open SHA_helpers
open X64.Machine_s
open X64.Vale.State
open X64.Vale.Decls
open X64.Vale.QuickCode
open X64.Vale.InsVector
open FStar.UInt32

open FStar.Seq
open Spec.Loops
open X64.CPU_Features_s
#endverbatim

#verbatim
open Types_s
open X64.Machine_s
open X64.Vale
open X64.Vale.State
open X64.Vale.StateLemmas
open X64.Vale.InsLemmas
open X64.Taint_Semantics
open X64.Vale.Decls
open X64.CryptoInstructions_s
open Spec.Hash.PadFinish
open Spec.Hash.Definitions
open Spec.SHA2
open X64.CPU_Features_s
module I = X64.Instructions_s
module S = X64.Bytes_Semantics_s
module TS = X64.Taint_Semantics_s
module P = X64.Print_s

friend X64.Vale.StateLemmas
friend X64.Vale.Decls
//#reset-options "--initial_fuel 4 --max_fuel 4 --max_ifuel 2 --z3rlimit 20"
//#reset-options "--initial_fuel 2 --max_fuel 2 --max_ifuel 2 --initial_ifuel 2 --z3rlimit 60"
#endverbatim

procedure{:instruction mk_ins(make_instr(I.ins_SHA256_rnds2, Mov128Xmm(dst), Mov128Xmm(src)), Public)}{:quick exportOnly}{:typecheck false}{:public} 
          SHA256_rnds2(inout dst:xmm, src:xmm, ghost t:counter, ghost block:block_w, ghost hash_orig:hash256)
    reads xmm0;
    requires 
        sha_enabled;
        t + 1 < size_k_w_256;
        xmm0.lo0 == add_wrap(word_to_nat32(index(k, t)),   ws_opaque(block, t));
        xmm0.lo1 == add_wrap(word_to_nat32(index(k, t+1)), ws_opaque(block, t + 1));
        make_hash(src, dst)      == repeat_range(0, t,   shuffle_core_opaque(block), hash_orig);
    ensures
        make_hash(dst, old(src)) == repeat_range(0, t+2, shuffle_core_opaque(block), hash_orig);
{
    lemma_sha256_rnds2(old(src), old(dst), old(xmm0), t, block, hash_orig);
}

procedure{:instruction mk_ins(make_instr(I.ins_SHA256_msg1, Mov128Xmm(dst), Mov128Xmm(src)), Public)}{:quick exportOnly}{:typecheck false}{:public} 
          SHA256_msg1(inout dst:xmm, src:xmm, ghost t:counter, ghost block:block_w)
    requires 
        sha_enabled;
        16 <= t < size_k_w_256;
        dst == ws_quad32(t-16, block);
        src.lo0 == ws_opaque(block, t-12);
    ensures
        dst == ws_partial(t, block);
{
    lemma_sha256_msg1(old(dst), old(src), t, block);
}

procedure{:instruction mk_ins(make_instr(I.ins_SHA256_msg2, Mov128Xmm(dst), Mov128Xmm(src)), Public)}{:quick exportOnly}{:typecheck false}{:public} 
          SHA256_msg2(inout dst:xmm, src:xmm, ghost t:counter, ghost block:block_w)
    requires 
        sha_enabled;
        16 <= t < size_k_w_256 - 3;
        let step1 := ws_partial(t, block) in
        let t_minus_7 := ws_quad32(t-7, block) in
        dst == add_wrap_quad32(step1,t_minus_7);
        src.hi2 == ws_opaque(block, t-2);
        src.hi3 == ws_opaque(block, t-1);
    ensures
        dst == ws_quad32(t, block);
{
    lemma_sha256_msg2(old(dst), old(src), t, block);
}
