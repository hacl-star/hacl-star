include{:fstar}{:open} "Types_s"
include{:fstar}{:open} "Arch.Types"
include{:fstar}{:open} "X64.Machine_s"
include{:fstar}{:open} "X64.Vale.State"
include{:fstar}{:open} "X64.Vale.Decls"
include{:fstar}{:open} "X64.Vale.QuickCode"
include{:fstar}{:open} "X64.CPU_Features_s"

module X64.Vale.InsBasic

#verbatim{:interface}
open Types_s
open Arch.Types
open X64.Machine_s
open X64.Vale.State
open X64.Vale.Decls
open X64.Vale.QuickCode
unfold let memory = X64.Memory.mem // avoid conflict with "var{...} mem" vs. "mem" from X64.Memory
unfold let stack_t = X64.Stack_i.stack // avoid conflict with "var{...} stack" vs. "stack" from X64.Stack_i
open X64.CPU_Features_s
#endverbatim

#verbatim
open X64.Vale
open X64.Vale.StateLemmas
open X64.Vale.InsLemmas
open X64.Taint_Semantics
open X64.CPU_Features_s
open X64.Memory
open X64.Stack_i
module I = X64.Instructions_s
module S = X64.Bytes_Semantics_s
module TS = X64.Taint_Semantics_s

friend X64.Vale.StateLemmas
friend X64.Vale.Decls

val lemma_valid_taint_match: (t:tainted_operand) -> (s:state) -> Lemma
  (requires valid_operand t s)
  (ensures TS.taint_match (t_op_to_op t) (get_taint t) s.memTaint s.stackTaint (state_to_S s).TS.state)
  [SMTPat (TS.taint_match (t_op_to_op t) (get_taint t) s.memTaint s.stackTaint (state_to_S s).TS.state)]

let lemma_valid_taint_match o s = match o with
  | TMem m t ->
    let addr = eval_maddr m s in
    let aux (b:buffer64) (i:int) : Lemma
      (requires valid_maddr addr s.mem s.memTaint b i t)
      (ensures TS.taint_match (t_op_to_op o) (get_taint o) s.memTaint s.stackTaint (state_to_S s).TS.state) = 
      X64.Memory.lemma_valid_taint64 b s.memTaint s.mem i t
    in Classical.forall_intro_2 (fun b i -> (fun b -> Classical.move_requires (aux b)) b i)
  | TStack m t -> lemma_valid_taint_stack64 (eval_maddr m s) t s.stackTaint
  | _ -> ()

#endverbatim

#reset-options "--initial_fuel 5 --max_fuel 5 --max_ifuel 2 --z3rlimit 20"

type memory:Type(1) := X64.Memory.mem;
type stack_t:Type(1) := X64.Stack_i.stack;

var ok:bool {:state ok()};
var rax:nat64 {:state reg(Rax)};
var rbx:nat64 {:state reg(Rbx)};
var rcx:nat64 {:state reg(Rcx)};
var rdx:nat64 {:state reg(Rdx)};
var rsi:nat64 {:state reg(Rsi)};
var rdi:nat64 {:state reg(Rdi)};
var rbp:nat64 {:state reg(Rbp)};
var rsp:nat64 {:state reg(Rsp)};
var r8:nat64  {:state reg(R8)};
var r9:nat64  {:state reg(R9)};
var r10:nat64 {:state reg(R10)};
var r11:nat64 {:state reg(R11)};
var r12:nat64 {:state reg(R12)};
var r13:nat64 {:state reg(R13)};
var r14:nat64 {:state reg(R14)};
var r15:nat64 {:state reg(R15)};
var efl:nat64 {:state flags()};
var mem:memory {:state mem()};
var stack:stack_t {:state stack()};
var memTaint:memtaint {:state memTaint()};
var stackTaint:memtaint {:state stackTaint()};

operand_type reg64:nat64 :=
| inout rax | inout rbx | inout rcx | inout rdx
| inout rsi | inout rdi | inout rbp | in rsp
| inout r8 | inout r9 | inout r10 | inout r11
| inout r12 | inout r13 | inout r14 | inout r15
;
operand_type shift_amt64:nat64 := in rcx | const;
operand_type reg_opr64:nat64 := reg64;
operand_type Mem(in base:reg64, inline offset:int, ghost b:buffer64, ghost index:int, inline t:taint):int;
operand_type Stack(in base:reg64, inline offset:int, inline t:taint):int;
operand_type dst_opr64:nat64 @ va_operand := reg_opr64 | Mem | Stack;
operand_type opr64:nat64 @ va_operand := dst_opr64 | const;

// add {:typecheck false} attr because Type0 is not defined. (TODO: get rid of this)
procedure AssertQuickType(ghost p:Type0) returns(ghost u:squash(p))
    {:public}
    {:quick exportOnly}
    {:typecheck false}
    requires
        p;
{
    u := tuple();
}

procedure Mov64(inout dst:dst_opr64, in src:opr64)
    {:public}
    {:quick exportOnly}
    {:instruction mk_taint_ins2(make_instr(I.ins_Mov64), dst, src)}
    ensures
        dst == old(src);
{
}

procedure Cmovc64(inout dst:dst_opr64, in src:opr64)
    {:public}
    {:quick exportOnly}
    {:instruction mk_taint_ins2(make_instr(I.ins_Cmovc64), dst, src)}
    reads efl;
    ensures
        if cf(efl) then dst = old(src) else dst = old(dst);
{
}

procedure Add64(inout dst:dst_opr64, in src:opr64)
    {:public}
    {:quick exportOnly}
    {:instruction mk_taint_ins2(make_instr(I.ins_Add64), dst, src)}
    modifies
        efl;
    requires
        src + dst < pow2_64;
    ensures
        dst == old(dst + src);
{
}

procedure Add64Wrap(inout dst:dst_opr64, in src:opr64)
    {:public}
    {:quick exportOnly}
    {:instruction mk_taint_ins2(make_instr(I.ins_Add64), dst, src)}
    modifies
        efl;
    ensures
        dst == old(add_wrap64(dst, src));
        cf(efl) == old(dst + src >= pow2_64);
{
}

procedure AddLea64(out dst:dst_opr64, in src1:opr64, in src2:opr64)
    {:public}
    {:quick exportOnly}
    {:instruction mk_taint_ins3(make_instr(I.ins_AddLea64), dst, src1, src2)}
    requires
        max_one_mem(@src1, @src2);
        src1 + src2 < pow2_64;
    ensures
        dst == old(src1) + old(src2);
{
}

procedure Adc64Wrap(inout dst:dst_opr64, in src:opr64)
    {:public}
    {:quick exportOnly}
    {:instruction mk_taint_ins2(make_instr(I.ins_AddCarry64), dst, src)}
    modifies
        efl;
    ensures
        dst == old(add_wrap64(add_wrap64(dst, src), (if cf(efl) then 1 else 0)));
        cf(efl) == old(dst + src + (if cf(efl) then 1 else 0)) >= pow2_64;
{
}

#reset-options "--initial_fuel 5 --max_fuel 5 --max_ifuel 2 --z3rlimit 20 --z3cliopt smt.arith.nl=true"
procedure Adcx64Wrap(inout dst:dst_opr64, in src:opr64)
    {:public}
    {:quick exportOnly}
    {:instruction mk_taint_ins2(make_instr(I.ins_Adcx64), dst, src)}
    requires adx_enabled;
    modifies
        efl;
    ensures
        dst == old(add_wrap64(add_wrap64(dst, src), (if cf(efl) then 1 else 0)));
        efl == update_cf(old(efl), old(dst + src + (if cf(efl) then 1 else 0)) >= pow2_64);
{
    assert old(add_wrap64(add_wrap64(dst, src), (if cf(efl) then 1 else 0)) == (dst + src + (if cf(efl) then 1 else 0)) % pow2_64); // REVIEW: shouldn't be necessary
}

#reset-options "--initial_fuel 5 --max_fuel 5 --max_ifuel 2 --z3rlimit 20"
procedure Adox64Wrap(inout dst:dst_opr64, in src:opr64)
    {:public}
    {:quick exportOnly}
    {:instruction mk_taint_ins2(make_instr(I.ins_Adox64), dst, src)}
    requires adx_enabled;
    modifies
        efl;
    ensures
        dst == old(add_wrap64(add_wrap64(dst, src), (if overflow(efl) then 1 else 0)));
        efl == update_of(old(efl), old(dst + src + (if overflow(efl) then 1 else 0)) >= pow2_64);
{
}

procedure Sub64(inout dst:dst_opr64, in src:opr64)
    {:public}
    {:quick exportOnly}
    {:instruction mk_taint_ins2(make_instr(I.ins_Sub64), dst, src)}
    requires
        0 <= dst - src;
    modifies
        efl;
    ensures
        dst == old(dst) - old(src);
{
}

procedure Sub64Wrap(inout dst:dst_opr64, in src:opr64)
    {:public}
    {:quick exportOnly}
    {:instruction mk_taint_ins2(make_instr(I.ins_Sub64), dst, src)}
    modifies
        efl;
    ensures
        dst == old(dst - src) % pow2_64;
        cf(efl) == old(dst - src < 0);
{
}

procedure Sbb64(inout dst:dst_opr64, in src:opr64)
    {:public}
    {:quick exportOnly}
    {:instruction mk_taint_ins2(make_instr(I.ins_Sbb64), dst, src)}
    modifies
        efl;
    ensures
        dst == old(dst - (src + (if cf(efl) then 1 else 0))) % pow2_64;
        cf(efl) == old(dst - (src + (if cf(efl) then 1 else 0))) < 0;
{
}

#reset-options "--max_fuel 0 --max_ifuel 0 --using_facts_from 'Prims FStar.UInt'"

#verbatim
let lemma_fundamental_div_mod (a b:nat64) :
  Lemma (pow2_64 `op_Multiply` (FStar.UInt.mul_div #64 a b) + (FStar.UInt.mul_mod #64 a b) == a `op_Multiply` b)
  =
  FStar.Math.Lemmas.lemma_div_mod (a `op_Multiply` b) pow2_64
#endverbatim

#reset-options "--initial_fuel 5 --max_fuel 5 --max_ifuel 2 --z3rlimit 20"

ghost procedure lemma_fundamental_div_mod(ghost a:nat64, ghost b:nat64) extern;

procedure Mul64Wrap(in src:opr64)
    {:public}
    {:quick exportOnly}
    {:instruction mk_taint_ins1(make_instr(I.ins_Mul64), src)}
    modifies
        efl;
        rax;
        rdx;
    ensures
        pow2_64 * rdx + rax == old(rax * src);
{
    lemma_fundamental_div_mod(old(rax), old(src));
}

procedure Mulx64(out dst_hi:dst_opr64, out dst_lo:dst_opr64, in src:opr64)
    {:public}
    {:quick exportOnly}
    {:instruction mk_taint_ins3(make_instr(I.ins_Mulx64), dst_hi, dst_lo, src)}
    requires bmi2_enabled; @dst_hi != @dst_lo; 
    reads
        rdx;
    ensures
        pow2_64 * dst_hi + dst_lo == old(rdx * src);
{
    lemma_fundamental_div_mod(old(rdx), old(src));
}

ghost procedure lemma_mul_nat(ghost x:nat, ghost y:nat) extern;
ghost procedure lemma_mul_in_bounds(ghost a:nat64, ghost b:nat64) extern;

procedure IMul64(inout dst:dst_opr64, in src:opr64)
    {:public}
    {:quick exportOnly}
    {:instruction mk_taint_ins2(make_instr(I.ins_IMul64), dst, src)}
    requires
        dst * src < pow2_64;
    modifies
        efl;
    ensures
        dst == old(dst * src);
{
    lemma_mul_nat(old(dst), old(src));
    lemma_mul_in_bounds(old(dst), old(src));
}

procedure Xor64(inout dst:dst_opr64, in src:opr64)
    {:public}
    {:quick exportOnly}
    {:instruction mk_taint_ins2(make_instr_annotate(I.ins_Xor64, S.AnnotateXor64()), dst, src)}
    modifies
        efl;
    ensures
        dst == old(ixor64(dst,src));
        !overflow(efl);
        !cf(efl);

{
}

procedure And64(inout dst:dst_opr64, in src:opr64)
    {:public}
    {:quick exportOnly}
    {:instruction mk_taint_ins2(make_instr(I.ins_And64), dst, src)}
    modifies
        efl;
    ensures
        dst == old(iand64(dst,src));
{
}

procedure Shl64(inout dst:dst_opr64, in amt:shift_amt64)
    {:public}
    {:quick exportOnly}
    {:instruction mk_taint_ins2(make_instr(I.ins_Shl64), dst, amt)}
    modifies
        efl;
//    requires
//        0 <= src < 64;
    ensures
        dst == old(ishl64(dst, amt));
{
}

procedure Shr64(inout dst:dst_opr64, in amt:shift_amt64)
    {:public}
    {:quick exportOnly}
    {:instruction mk_taint_ins2(make_instr(I.ins_Shr64), dst, amt)}
    modifies
        efl;
    ensures
        dst == old(ishr64(dst, amt));
{
}

procedure Cpuid_AES()
    {:public}
    {:quick exportOnly}
    {:instruction mk_ins(make_instr(I.ins_Cpuid), Public)}
    requires rax = 1;
    modifies rax; rbx; rcx; rdx;
    ensures
        (iand64(rcx, 0x2000000) > 0) == aesni_enabled;
        (iand64(rcx, 0x2) > 0) == pclmulqdq_enabled;
{
    cpuid_features();
}

procedure Cpuid_Sha()
    {:public}
    {:quick exportOnly}
    {:instruction mk_ins(make_instr(I.ins_Cpuid), Public)}
    requires
        rax = 7;
        rcx = 0;
    modifies rax; rbx; rcx; rdx;
    ensures (iand64(rbx, 0x20000000) > 0) == sha_enabled;
{
    cpuid_features();
}

procedure Cpuid_Adx_Bmi2()
    {:public}
    {:quick exportOnly}
    {:instruction mk_ins(make_instr(I.ins_Cpuid), Public)}
    requires
        rax = 7;
        rcx = 0;
    modifies rax; rbx; rcx; rdx;
    ensures 
        (iand64(rbx, 0x100) > 0) == bmi2_enabled;
        (iand64(rbx, 0x80000) > 0) == adx_enabled;
{
    cpuid_features();
}

procedure Cpuid_Avx()
    {:public}
    {:quick exportOnly}
    {:instruction mk_ins(make_instr(I.ins_Cpuid), Public)}
    requires rax = 1;
    modifies rax; rbx; rcx; rdx;
    ensures (iand64(rcx, 0x10000000) > 0) == avx_enabled;
{
    cpuid_features();
}

procedure Cpuid_Avx2()
    {:public}
    {:quick exportOnly}
    {:instruction mk_ins(make_instr(I.ins_Cpuid), Public)}
    requires
        rax = 7;
        rcx = 0;
    modifies rax; rbx; rcx; rdx;
    ensures (iand64(rbx, 0x20) > 0) == avx2_enabled;
{
    cpuid_features();
}

