FSTAR_HOME	?= ../../FStar
KREMLIN_HOME	?= ../../kremlin
HACL_HOME	?= ..
OPENSSL_HOME	?= ../../MLCrypto/openssl

CACHE_DIR	= .cache
OUTPUT_DIR	= .output
GENERATED_DIR	= generated
OUT_DIR		= out

HACL_CODE	= $(HACL_HOME)/code
HACL_SPEC	= $(HACL_HOME)/specs

# 0. The usual pseudo auto-configuration

UNAME		= $(shell uname)
SED		= $(shell which gsed >/dev/null 2>&1 && echo gsed || echo sed)
MARCH		= x86_64
ifeq ($(UNAME),Darwin)
  VARIANT	= -Darwin
  SO		= so
else ifeq ($(UNAME),Linux)
  CFLAGS	+= -fPIC
  VARIANT	= -Linux
  SO 		= so
  LDFLAGS	+= -Xlinker -z -Xlinker noexecstack -Xlinker --unresolved-symbols=report-all
else ifeq ($(OS),Windows_NT)
  CC		= $(MARCH)-w64-mingw32-gcc
  AR		= $(MARCH)-w64-mingw32-ar
  SO		= dll
endif

# Manual staging...
all:
	rm -f .depend && $(MAKE) .depend
	$(MAKE) all_

all_: $(OUT_DIR)/libevercrypt.a $(OUT_DIR)/libevercrypt.$(SO) $(OUT_DIR)/evercrypt.cmxa

test: sample-project/sample-project.exe
	LD_LIBRARY_PATH=. DYLD_LIBRARY_PATH=. PATH=. ./$<

# 1. Generation of the .krml files
# - generate the F* dependency graph via `fstar --dep full`
# - verify every F* file in parallel to generate .checked files
# - extract each .checked file into a .krml file in parallel

FSTAR_INCLUDES = $(KREMLIN_HOME)/kremlib multiplexer multiplexer/fst \
  $(HACL_CODE)/lib/kremlin $(HACL_CODE)/curve25519/interfaces $(HACL_CODE)/hash/interfaces \
  $(HACL_SPEC)
FSTAR		= $(FSTAR_HOME)/bin/fstar.exe --cache_checked_modules \
  --use_two_phase_tc true --admit_smt_queries true $(OTHERFLAGS) \
  --cache_dir $(CACHE_DIR) --odir $(OUTPUT_DIR) \
  $(addprefix --include ,$(FSTAR_INCLUDES)) \
  --use_hints # --record_hints --hint_info

ROOTS		= EverCrypt.fst EverCrypt.Bytes.fsti

.PRECIOUS: %.krml

.depend:
	$(FSTAR) --dep full $(ROOTS) --extract Kremlin > $@

include .depend

$(CACHE_DIR)/%.checked: | .depend
	$(FSTAR) $< && \
	touch $@

$(OUTPUT_DIR)/%.krml: | .depend
	$(FSTAR) --codegen Kremlin \
	  --extract_module $(basename $(notdir $(subst .checked,,$<))) \
	  $(notdir $(subst .checked,,$<)) && \
	touch $@

# 2. Generation of the .c files
ifneq (,$(EVEREST_WINDOWS))
KOPTS		+=-falloca -ftail-calls -fnouint128 -drop FStar.UInt128 \
  -add-early-include '"FStar_UInt128.h"'
CFLAGS	+=-DNO_OPENSSL
endif

$(GENERATED_DIR)/Makefile.include: $(ALL_KRML_FILES) | .depend
	$(KREMLIN_HOME)/krml -skip-compilation -minimal \
	  -add-include '"kremlib.h"' -add-include '"kremlin/c_string.h"' \
	  -bundle 'FStar.*,Prims,C.Loops,Spec.*,Hacl.Spec.*,Seq.*' \
	  -bundle 'LowStar.*' \
	  -tmpdir generated $^ -warn-error +9 \
	  && \
	touch $@

# This will generate an error the first time this Makefile is invoked because
# $(ALL_KRML_FILES) is empty. This is why we need to stage the `all` target.
-include $(GENERATED_DIR)/Makefile.include


# 3. Collecting all of our source files, and generating corresponding object
# files.

# TODO: grab these directly from Vale and error out with a helpful make target,
# like for HACL*.
VALE_DIR 	= $(HACL_HOME)/secure_api/vale/asm
VALE_SOURCES	= $(addprefix $(VALE_DIR)/,sha256_main_i.c \
  vale_aes_glue.c Vale_Hash_SHA2_256.c)
VALE_ASM 	= $(addprefix $(VALE_DIR)/,\
  sha256-$(MARCH)$(VARIANT).S aes-$(MARCH)$(VARIANT).S aesgcm-$(MARCH)$(VARIANT).S)

# TODO: understand why these two targets are broken/possibly switch to a HACL*
# branch where their compilation is restored.
# - aead-c: kremlin seems to generate an extra argument, JK had a hack to sed
#   the code in place
HACL_SOURCES	= \
  $(HACL_CODE)/salsa-family/chacha-c/Hacl_Chacha20.c \
  $(HACL_CODE)/salsa-family/salsa-c/Hacl_Salsa20.c \
  $(addprefix $(HACL_CODE)/hash/sha2-c/Hacl_SHA2_,256.c 384.c 512.c) \
  $(HACL_CODE)/curve25519/x25519-c/Hacl_Curve25519.c \
  $(HACL_CODE)/ed25519/ed25519-c/Hacl_Ed25519.c \
  $(HACL_CODE)/poly1305/poly-c/Hacl_Poly1305_64.c \
  $(HACL_CODE)/hmac/hmac-c/Hacl_HMAC_SHA2_256.c \
  $(HACL_CODE)/poly1305/poly-c/AEAD_Poly1305_64.c \
  $(HACL_CODE)/salsa-family/chacha-vec128-c/Hacl_Chacha20_Vec128.c \
  #$(HACL_CODE)/api/aead-c/Chacha20Poly1305.c \

EVERCRYPT_SOURCES = \
  $(addprefix $(GENERATED_DIR)/,EverCrypt.c EverCrypt_Helpers.c) \
  $(addprefix multiplexer/c/evercrypt_,native.c vale.c bytes.c openssl.c)

# This is auto-generated by KreMLin; since the Makefile is staged via the
# inclusion of Makefile.include, the automated dependency analysis via $(CC) -MM
# also captures the dependencies between these files.
#
# KreMLin sees the fsti's for the various Hacl_* modules and creates .h/.c
# files for them in generated/. However, we are only interested in the header,
# and drop these (mostly empty) C files, since the "real" ones are collected via
# HACL_SOURCES above.
ALL_OUR_FILES 	= $(filter-out Hacl_%,$(ALL_C_FILES))
ALL_GENERATED_FILES = $(addprefix $(GENERATED_DIR)/,$(ALL_OUR_FILES))


ALL_SOURCES	= $(HACL_SOURCES) $(VALE_SOURCES) $(EVERCRYPT_SOURCES) $(ALL_GENERATED_FILES)
ALL_OBJS	= $(patsubst %.c,%.o,$(ALL_SOURCES)) $(patsubst %.S,%.o,$(VALE_ASM))

INCLUDE_DIRS	= $(foreach c,$(ALL_SOURCES),$(dir $(c))) \
  $(HACL_HOME)/secure_api/out/runtime_switch/extracted \
  $(HACL_HOME)/snapshots/common $(KREMLIN_HOME)/include \
  $(OPENSSL_HOME)/include


CFLAGS		+= $(addprefix -I ,$(INCLUDE_DIRS)) -Wall -Wextra -Werror \
  -Wno-parentheses -Wno-unused-parameter -Wno-infinite-recursion

ifneq (,$(EVEREST_WINDOWS))
FSTAR_UINT128	= ../secure_api/out/runtime_switch/uint128/FStar_UInt128.c
ALL_GENERATED_FILES += $(FSTAR_UINT128)
INCLUDE_DIRS	+= ../secure_api/out/runtime_switch/uint128
CFLAGS		+= -DKRML_NOUINT128

$(FSTAR_UINT128):
	$(error Please run make -C ../secure_api before invoking this Makefile)
endif

# GNU Make manual section 4.14
%.d: %.c
	@set -e; rm -f $@; \
	  $(CC) -MM $(CFLAGS) $< > $@.$$$$; \
	  sed 's,\($(notdir $*)\)\.o[ :]*,$(dir $@)\1.o $@ : ,g' < $@.$$$$ > $@; \
	  rm -f $@.$$$$

-include $(addsuffix .d,$(ALL_SOURCES))

$(OUT_DIR):
	mkdir -p $@

# 4. Collecting all of the object files into a static and a dynamic library.

ifeq (,$(EVEREST_WINDOWS))
LDFLAGS += -L$(OPENSSL_HOME) -lcrypto
ifeq ($(UNAME),Linux)
LDFLAGS += -ldl -lpthread
endif
endif

# Note: see
# https://www.gnu.org/software/make/manual/html_node/Archive-Pitfalls.html#Archive-Pitfalls
# for why we are not using libhacl.a($(OBJS))
$(OUT_DIR)/libevercrypt.a: $(ALL_OBJS) | $(OUT_DIR)
	$(AR) cr $@ $^

$(OUT_DIR)/libevercrypt.$(SO): $(ALL_OBJS) | $(OUT_DIR)
	$(CC) -shared $^ $(LDFLAGS) -o $@

.PRECIOUS: %.o

$(HACL_SOURCES):
	$(error "Please run `make -j 8 -C $(HACL_CODE) extract-c` before invoking this Makefile")

.PHONY: clean
clean:
	rm -rf $(GENERATED_DIR) multiplexer/c/*.o libevercrypt.so libevercrypt.a test/sample-project.exe

.PHONY: distclean
distclean: clean
	rm -rf $(OUT_DIR) $(CACHE_DIR)

# 5. A sample project that is a client of the library; run in a single
# invocation of KreMLin for simplicity; essentially checks that separate linking
# works.

sample-project/sample-project.exe: sample-project/SampleProject.fst $(OUT_DIR)/libevercrypt.so
	$(KREMLIN_HOME)/krml -ldopt -levercrypt $< -no-prefix SampleProject \
	  -I multiplexer/ -add-include '"kremlin/c_string.h"' KRML_HOME/kremlib/testlib.c \
	  -tmpdir .sample-project \
	  -add-include '"kremlin/testlib.h"' -ldopt -Lout -o $@

# 6. An OCaml library that exposes only the bytes-based interface, for now

$(OUT_DIR)/evercrypt.cmxa: multiplexer/ml/EverCrypt_Bytes.ml | $(OUT_DIR)/libevercrypt.$(SO) $(OUT_DIR)
	ocamlfind mklib -package ctypes,ctypes.foreign -cclib -levercrypt \
	  -cclib -Lout -cclib -lcrypto -L$(OPENSSL_HOME) \
	  -o $(patsubst %.cmxa,%,$@) $^
