module Hacl.Impl.Ed25519.Pow2_252m2

open FStar.HyperStack.All

module ST = FStar.HyperStack.ST

let equal_domains = ST.equal_domains

open FStar.Mul
open FStar.HyperStack
open FStar.Buffer

open Hacl.Bignum25519


(* #reset-options "--max_fuel 0 --z3rlimit 10" *)

(* inline_for_extraction *)
(* private *)
(* val fmul: *)
(*   output:felem -> *)
(*   a:felem -> *)
(*   b:felem -> *)
(*   Stack unit *)
(*     (requires (fun h -> live h output /\ live h a /\ live h b *)
(*       /\ red_513 (as_seq h a) /\ red_513 (as_seq h b))) *)
(*     (ensures (fun h0 _ h1 -> live h0 output /\ live h0 a /\ live h0 b *)
(*       /\ red_513 (as_seq h0 a) /\ red_513 (as_seq h0 b) *)
(*       /\ modifies_1 output h0 h1 /\ live h1 output *)
(*       /\ red_513 (as_seq h1 output) /\ *)
(*       seval (as_seq h1 output) == Spec.Curve25519.(seval (as_seq h0 a) *@ seval (as_seq h0 b)) *)
(*       (\* /\ Hacl.Spec.Bignum.Fmul.fmul_pre (as_seq h0 a) (as_seq h0 b) *\) *)
(*       (\* /\ as_seq h1 output == Hacl.Spec.Bignum.fmul_tot (as_seq h0 a) (as_seq h0 b) *\) *)
(*       )) *)
(* inline_for_extraction *)
(* private let fmul output a b = *)
(*   let h = ST.get() in *)
(*   lemma_red_513_is_red_53 (as_seq h a); *)
(*   lemma_red_513_is_red_5413 (as_seq h b); *)
(*   fmul output a b *)


(* #reset-options "--max_fuel 0 --z3rlimit 10" *)

(* inline_for_extraction *)
(* inline_for_extraction private val fsquare_times: *)
(*   output:felem -> *)
(*   input:felem{disjoint output input} -> *)
(*   count:FStar.UInt32.t{FStar.UInt32.v count > 0} -> *)
(*   Stack unit *)
(*     (requires (fun h -> live h output /\ live h input *)
(*       /\ red_513 (as_seq h input))) *)
(*     (ensures (fun h0 _ h1 -> live h0 output /\ live h1 output /\ live h0 input /\ modifies_1 output h0 h1 *)
(*       /\ red_513 (as_seq h0 input) *)
(*       /\ red_513 (as_seq h1 output) *)
(*       (\* /\ (as_seq h1 output) == Hacl.Spec.Bignum.Fsquare.fsquare_times_tot (as_seq h0 input) (FStar.UInt32.v count))) *\) *)
(*       )) *)
(* inline_for_extraction *)
(* inline_for_extraction private let fsquare_times output input count = *)
(*   (\* let h = ST.get() in *\) *)
(*   (\* lemma_513_is_5413 (as_seq h input); *\) *)
(*   fsquare_times output input count *)


(* inline_for_extraction *)
(* inline_for_extraction private val fsquare_times_inplace: *)
(*   output:felem -> *)
(*   count:FStar.UInt32.t{FStar.UInt32.v count > 0} -> *)
(*   Stack unit *)
(*     (requires (fun h -> live h output /\ red_513 (as_seq h output))) *)
(*     (ensures (fun h0 _ h1 -> live h0 output /\ live h1 output /\ modifies_1 output h0 h1 *)
(*       /\ red_513 (as_seq h0 output) *)
(*       /\ red_513 (as_seq h1 output) *)
(*       (\* /\ (as_seq h1 output) == Hacl.Spec.Bignum.Fsquare.fsquare_times_tot (as_seq h0 output) (FStar.UInt32.v count) *\) *)
(*     )) *)
(* inline_for_extraction *)
(* inline_for_extraction private let fsquare_times_inplace output count = *)
(*   (\* let h = ST.get() in *\) *)
(*   (\* lemma_513_is_5413 (as_seq h output); *\) *)
(*   fsquare_times_inplace output count *)


(* private val lemma_crecip_1_modifies': h0:mem -> h1:mem -> b:buffer limb -> Lemma (requires (equal_domains h0 h1 /\ live h0 b /\ modifies_1 b h0 h1)) *)
(*   (ensures (live h1 b)) *)
(* private let lemma_crecip_1_modifies' h0 h1 b = () *)
 

(* private val lemma_crecip_1_modifies'': h0:mem -> h1:mem -> h2:mem -> h3:mem -> h4:mem -> h5:mem -> h6:mem -> h7:mem -> buf:buffer limb{length buf = 20} -> *)
(*   Lemma (requires ( *)
(*     let a  = Buffer.sub buf 0ul  5ul in *)
(*     let t0 = Buffer.sub buf 5ul  5ul in *)
(*     let b  = Buffer.sub buf 10ul 5ul in *)
(*     let c  = Buffer.sub buf 15ul 5ul in *)
(*     live h0 buf /\ modifies_1 a h0 h1 /\ modifies_1 t0 h1 h2 /\ modifies_1 b h2 h3 /\ modifies_1 a h3 h4 *)
(*     /\ modifies_1 t0 h4 h5 /\ modifies_1 b h5 h6 /\ modifies_1 t0 h6 h7 /\ equal_domains h0 h7)) *)
(*         (ensures (modifies_1 buf h0 h7)) *)
(* private let lemma_crecip_1_modifies'' h0 h1 h2 h3 h4 h5 h6 h7 buf = () *)

(* private val lemma_crecip_1_modifies: h0:mem -> h1:mem -> h2:mem -> h3:mem -> h4:mem -> h5:mem -> h6:mem -> h7:mem -> buf:buffer limb{length buf = 20} -> *)
(*   Lemma (requires ( *)
(*     let a  = Buffer.sub buf 0ul  5ul in *)
(*     let t0 = Buffer.sub buf 5ul  5ul in *)
(*     let b  = Buffer.sub buf 10ul 5ul in *)
(*     let c  = Buffer.sub buf 15ul 5ul in *)
(*     live h0 buf /\ modifies_1 a h0 h1 /\ modifies_1 t0 h1 h2 /\ modifies_1 b h2 h3 /\ modifies_1 a h3 h4 *)
(*     /\ modifies_1 t0 h4 h5 /\ modifies_1 b h5 h6 /\ modifies_1 t0 h6 h7 /\ equal_domains h0 h7)) *)
(*         (ensures (modifies_1 buf h0 h7 /\ live h7 buf)) *)
(* private let lemma_crecip_1_modifies h0 h1 h2 h3 h4 h5 h6 h7 buf = *)
(*   lemma_crecip_1_modifies'' h0 h1 h2 h3 h4 h5 h6 h7 buf; *)
(*   lemma_crecip_1_modifies' h0 h7 buf *)


(* inline_for_extraction *)
(* private inline_for_extraction val crecip_1: *)
(*   buf:buffer limb{length buf = 20} -> *)
(*   z:felem{disjoint buf z} -> *)
(*   Stack unit *)
(*   (requires (fun h -> live h buf /\ live h z (\* /\ crecip_pre (as_seq h z) *\))) *)
(*   (ensures (fun h0 _ h1 -> live h1 z /\ live h1 buf /\ modifies_1 buf h0 h1 /\ live h0 buf /\ live h0 z *)
(*     (\* /\ crecip_pre (as_seq h0 z) *\) *)
(*     (\* /\ (let a  = Buffer.sub buf 0ul  5ul in *\) *)
(*     (\*    let t0 = Buffer.sub buf 5ul  5ul in *\) *)
(*     (\*    let b  = Buffer.sub buf 10ul 5ul in *\) *)
(*     (\*    let c  = Buffer.sub buf 15ul 5ul in *\) *)
(*     (\*    crecip_pre (as_seq h1 t0) *\) *)
(*     (\*    /\ crecip_pre (as_seq h1 b) *\) *)
(*     (\*    /\ crecip_pre (as_seq h1 a) *\) *)
(*     (\*    /\ ( (as_seq h1 t0, as_seq h1 b, as_seq h1 a)  == crecip_tot_1 (as_seq h0 z))) *\) *)
(*   )) *)
(* #reset-options "--initial_fuel 0 --max_fuel 0 --z3rlimit 100" *)
(* inline_for_extraction *)
(* private inline_for_extraction let crecip_1 buf z = *)
(*   let a  = Buffer.sub buf 0ul  5ul in *)
(*   let t0 = Buffer.sub buf 5ul  5ul in *)
(*   let b  = Buffer.sub buf 10ul 5ul in *)
(*   let c  = Buffer.sub buf 15ul 5ul in *)
(*   let h0 = ST.get() in *)
(*   fsquare_times a z 1ul; *)
(*   let h1 = ST.get() in *)
(*   no_upd_lemma_1 h0 h1 a z; *)
(*   fsquare_times t0 a 2ul; *)
(*   let h2 = ST.get() in *)
(*   no_upd_lemma_1 h1 h2 t0 z; *)
(*   no_upd_lemma_1 h1 h2 t0 a; *)
(*   fmul b t0 z; *)
(*   let h3 = ST.get() in *)
(*   no_upd_lemma_1 h2 h3 b a; *)
(*   fmul a b a; *)
(*   let h4 = ST.get() in *)
(*   fsquare_times t0 a 1ul; *)
(*   let h5 = ST.get() in *)
(*   no_upd_lemma_1 h3 h4 a b; *)
(*   no_upd_lemma_1 h4 h5 t0 b; *)
(*   fmul b t0 b; *)
(*   let h6 = ST.get() in *)
(*   fsquare_times t0 b 5ul; *)
(*   let h7 = ST.get() in *)
(*   no_upd_lemma_1 h6 h7 t0 b; *)
(*   no_upd_lemma_1 h4 h5 t0 a; *)
(*   no_upd_lemma_1 h5 h6 b  a; *)
(*   no_upd_lemma_1 h6 h7 t0 a(\* ; *\) *)
(*   (\* lemma_crecip_1_modifies h0 h1 h2 h3 h4 h5 h6 h7 buf *\) *)


(* private val lemma_crecip_2_modifies: h0:mem -> h1:mem -> h2:mem -> h3:mem -> h4:mem -> h5:mem -> h6:mem -> h7:mem -> h8:mem -> buf:buffer limb{length buf = 20} -> *)
(*   Lemma (requires ( *)
(*     let a  = Buffer.sub buf 0ul  5ul in *)
(*     let t0 = Buffer.sub buf 5ul  5ul in *)
(*     let b  = Buffer.sub buf 10ul 5ul in *)
(*     let c  = Buffer.sub buf 15ul 5ul in *)
(*     live h0 buf /\ modifies_1 b h0 h1 /\ modifies_1 t0 h1 h2 /\ modifies_1 c h2 h3 /\ modifies_1 t0 h3 h4 *)
(*     /\ modifies_1 t0 h4 h5 /\ modifies_1 t0 h5 h6 /\ modifies_1 b h6 h7 /\ modifies_1 t0 h7 h8 /\ equal_domains h0 h8)) *)
(*         (ensures (modifies_1 buf h0 h8 /\ live h8 buf)) *)
(* private let lemma_crecip_2_modifies h0 h1 h2 h3 h4 h5 h6 h7 h8 buf = *)
(*   cut (modifies_1 buf h0 h8); *)
(*   lemma_crecip_1_modifies' h0 h8 buf *)


(* inline_for_extraction *)
(* private inline_for_extraction val crecip_2: *)
(*   buf:buffer limb{length buf = 20} -> *)
(*   Stack unit *)
(*   (requires (fun h -> live h buf *)
(*     /\ (let a  = Buffer.sub buf 0ul  5ul in *)
(*        let t0 = Buffer.sub buf 5ul  5ul in *)
(*        let b  = Buffer.sub buf 10ul 5ul in *)
(*        let c  = Buffer.sub buf 15ul 5ul in *)
(*        red_513 (as_seq h t0) *)
(*        /\ red_513 (as_seq h b) *)
(*        /\ red_513 (as_seq h a)) *)
(*       )) *)
(*   (ensures (fun h0 _ h1 -> live h1 buf /\ modifies_1 buf h0 h1 /\ live h0 buf *)
(*     /\ (let a  = Buffer.sub buf 0ul  5ul in *)
(*        let t0 = Buffer.sub buf 5ul  5ul in *)
(*        let b  = Buffer.sub buf 10ul 5ul in *)
(*        let c  = Buffer.sub buf 15ul 5ul in *)
(*        red_513 (as_seq h0 t0) *)
(*        /\ red_513 (as_seq h0 b) *)
(*        /\ red_513 (as_seq h0 a) *)
(*        (\* /\ crecip_pre (as_seq h1 t0) *\) *)
(*        (\* /\ crecip_pre (as_seq h1 b) *\) *)
(*        (\* /\ crecip_pre (as_seq h1 a) *\) *)
(*        (\* /\ ( (as_seq h1 t0, as_seq h1 b, as_seq h1 a)  == crecip_tot_2 (as_seq h0 t0) (as_seq h0 b) (as_seq h0 a))) *\) *)
(*        ) *)
(*   )) *)
(* #reset-options "--initial_fuel 0 --max_fuel 0 --z3rlimit 200" *)
(* inline_for_extraction *)
(* private inline_for_extraction let crecip_2 buf = *)
(*   assert_norm(pow2 32 = 0x100000000); *)
(*   let a  = Buffer.sub buf 0ul  5ul in *)
(*   let t0 = Buffer.sub buf 5ul  5ul in *)
(*   let b  = Buffer.sub buf 10ul 5ul in *)
(*   let c  = Buffer.sub buf 15ul 5ul in *)
(*   let h0 = ST.get() in *)
(*   fmul b t0 b; *)
(*   let h1 = ST.get() in *)
(*   no_upd_lemma_1 h0 h1 b a; *)
(*   (\* no_upd_lemma_1 h0 h1 b t0; *\) *)
(*   fsquare_times t0 b 10ul; *)
(*   let h2 = ST.get() in *)
(*   (\* no_upd_lemma_1 h1 h2 b t0; *\) *)
(*   no_upd_lemma_1 h1 h2 t0 a; *)
(*   fmul c t0 b; *)
(*   let h3 = ST.get() in *)
(*   no_upd_lemma_1 h2 h3 c b; *)
(*   no_upd_lemma_1 h2 h3 c a; *)
(*   (\* no_upd_lemma_1 h2 h3 c t0; *\) *)
(*   fsquare_times t0 c 20ul; *)
(*   let h4 = ST.get() in *)
(*   no_upd_lemma_1 h3 h4 t0 b; *)
(*   no_upd_lemma_1 h3 h4 t0 a; *)
(*   fmul t0 t0 c; *)
(*   let h5 = ST.get() in *)
(*   no_upd_lemma_1 h4 h5 t0 b; *)
(*   no_upd_lemma_1 h4 h5 t0 a; *)
(*   fsquare_times_inplace t0 10ul; *)
(*   let h6 = ST.get() in *)
(*   no_upd_lemma_1 h5 h6 t0 b; *)
(*   no_upd_lemma_1 h5 h6 t0 a; *)
(*   fmul b t0 b; *)
(*   let h7 = ST.get() in *)
(*   no_upd_lemma_1 h6 h7 b a; *)
(*   no_upd_lemma_1 h6 h7 b t0; *)
(*   fsquare_times t0 b 50ul; *)
(*   let h8 = ST.get() in *)
(*   no_upd_lemma_1 h7 h8 t0 a; *)
(*   no_upd_lemma_1 h7 h8 t0 b; *)
(*   cut (red_513 (as_seq h8 b)); *)
(*   cut (red_513 (as_seq h8 a)); *)
(*   cut (red_513 (as_seq h8 t0)); *)
(*   lemma_crecip_2_modifies h0 h1 h2 h3 h4 h5 h6 h7 h8 buf *)


(* private val lemma_crecip_3_modifies: h0:mem -> h1:mem -> h2:mem -> h3:mem -> h4:mem -> h5:mem -> h6:mem -> h7:mem -> buf:buffer limb{length buf = 20} -> out:felem{disjoint buf out} -> *)
(*   Lemma (requires ( *)
(*     let a  = Buffer.sub buf 0ul  5ul in *)
(*     let t0 = Buffer.sub buf 5ul  5ul in *)
(*     let b  = Buffer.sub buf 10ul 5ul in *)
(*     let c  = Buffer.sub buf 15ul 5ul in *)
(*     live h0 buf /\ live h0 out *)
(*     /\ modifies_1 c h0 h1 /\ modifies_1 t0 h1 h2 /\ modifies_1 t0 h2 h3 /\ modifies_1 t0 h3 h4 *)
(*     /\ modifies_1 t0 h4 h5 /\ modifies_1 t0 h5 h6 /\ modifies_1 out h6 h7 /\ equal_domains h0 h7)) *)
(*         (ensures (modifies_2 out buf h0 h7 /\ live h7 out)) *)
(* private let lemma_crecip_3_modifies h0 h1 h2 h3 h4 h5 h6 h7 buf out = () *)


(* inline_for_extraction *)
(* private inline_for_extraction val crecip_3: *)
(*   out:felem -> *)
(*   buf:buffer limb{length buf = 20 /\ disjoint out buf} -> *)
(*   Stack unit *)
(*   (requires (fun h -> live h buf /\ live h out *)
(*     /\ (let a  = Buffer.sub buf 0ul  5ul in *)
(*        let t0 = Buffer.sub buf 5ul  5ul in *)
(*        let b  = Buffer.sub buf 10ul 5ul in *)
(*        let c  = Buffer.sub buf 15ul 5ul in *)
(*        red_513 (as_seq h t0) *)
(*        /\ red_513 (as_seq h b) *)
(*        /\ red_513 (as_seq h a)) *)
(*       )) *)
(*   (ensures (fun h0 _ h1 -> live h1 out /\ modifies_2 out buf h0 h1 /\ live h0 buf *)
(*      (\* /\ crecip_pre (as_seq h1 out) *\) *)
(*      /\ (let a  = Buffer.sub buf 0ul  5ul in *)
(*        let t0 = Buffer.sub buf 5ul  5ul in *)
(*        let b  = Buffer.sub buf 10ul 5ul in *)
(*        let c  = Buffer.sub buf 15ul 5ul in  *)
(*        red_513 (as_seq h0 t0) *)
(*        /\ red_513 (as_seq h0 b) *)
(*        /\ red_513 (as_seq h0 a)) *)
(*        (\* /\ as_seq h1 out  == crecip_tot_3 (as_seq h0 t0) (as_seq h0 b) (as_seq h0 a)) *\) *)
(*   )) *)
(* #reset-options "--initial_fuel 0 --max_fuel 0 --z3rlimit 100" *)
(* inline_for_extraction *)
(* private inline_for_extraction let crecip_3 out buf = *)
(*   assert_norm(pow2 32 = 0x100000000); *)
(*   let a  = Buffer.sub buf 0ul  5ul in *)
(*   let t0 = Buffer.sub buf 5ul  5ul in *)
(*   let b  = Buffer.sub buf 10ul 5ul in *)
(*   let c  = Buffer.sub buf 15ul 5ul in *)
(*   let h0 = ST.get() in *)
(*   fmul c t0 b; *)
(*   let h1 = ST.get() in *)
(*   no_upd_lemma_1 h0 h1 c b; *)
(*   no_upd_lemma_1 h0 h1 c t0; *)
(*   no_upd_lemma_1 h0 h1 c a; *)
(*   fsquare_times t0 c 100ul; *)
(*   let h2 = ST.get() in *)
(*   no_upd_lemma_1 h1 h2 t0 b; *)
(*   no_upd_lemma_1 h1 h2 t0 a; *)
(*   fmul t0 t0 c; *)
(*   let h3 = ST.get() in *)
(*   no_upd_lemma_1 h2 h3 t0 b; *)
(*   no_upd_lemma_1 h2 h3 t0 a; *)
(*   fsquare_times_inplace t0 50ul; *)
(*   let h4 = ST.get() in *)
(*   no_upd_lemma_1 h3 h4 t0 b; *)
(*   no_upd_lemma_1 h3 h4 t0 a; *)
(*   fmul t0 t0 b; *)
(*   let h5 = ST.get() in *)
(*   no_upd_lemma_1 h4 h5 t0 a; *)
(*   fsquare_times_inplace t0 2ul *)
  
(*   (\* ; *\) *)
(*   (\* let h6 = ST.get() in *\) *)
(*   (\* no_upd_lemma_1 h5 h6 t0 a *\) *)
  
(*   (\* ; *\) *)
(*   (\* fmul out t0 a; *\) *)
(*   (\* let h7 = ST.get() in *\) *)
(*   (\* lemma_crecip_3_modifies h0 h1 h2 h3 h4 h5 h6 h7 buf out *\) *)


(* (\* inline_for_extraction *\) *)
(* (\* val pow2_252m2: *\) *)
(* (\*   out:felem -> *\) *)
(* (\*   z:felem{disjoint out z} -> *\) *)
(* (\*   Stack unit *\) *)
(* (\*   (requires (fun h -> live h out /\ live h z (\\* /\ crecip_pre (as_seq h z) *\\) /\ red_513 (as_seq h z))) *\) *)
(* (\*   (ensures (fun h0 _ h1 -> live h1 out /\ modifies_1 out h0 h1 /\ live h0 z *\) *)
(* (\*     /\ red_513 (as_seq h0 z) *\) *)
(* (\*     (\\* /\ crecip_pre (as_seq h0 z) *\\) *\) *)
(* (\*     (\\* /\ as_seq h1 out == crecip_tot (as_seq h0 z) *\\) *\) *)
(* (\*     /\ Hacl.Spec.Bignum.Bigint.seval (as_seq h1 out) == Spec.Curve25519.(Hacl.Spec.Bignum.Bigint.seval (as_seq h0 z) ** ((prime + 3) / 8)) *\) *)
(* (\*     /\ red_513 (as_seq h1 out) *\) *)
(* (\*     (\\* /\ crecip_pre (as_seq h1 out) *\\) *\) *)
(* (\*   )) *\) *)


#reset-options "--max_fuel 0 --z3rlimit 50"

inline_for_extraction
let pow2_252m2 out z =
  assert_norm(((pow2 255 - 19) + 3) / 8 = pow2 252 - 2);
  let h  = ST.get() in
  lemma_reveal_red_513 (as_seq h z);
  lemma_reveal_seval (as_seq h z);
  Hacl.Spec.Bignum.Modulo.lemma_seval_5 (as_seq h z);
  Hacl.Bignum.Crecip.crecip' out z;
  let h' = ST.get() in
  lemma_reveal_seval (as_seq h' out);
  Hacl.Spec.Bignum.Modulo.lemma_seval_5 (as_seq h' out);
  lemma_intro_red_513 (as_seq h' out)

  (* push_frame(); *)
  (* let buf = create 0uL 20ul in *)
  (* crecip_1 buf z; *)
  (* crecip_2 buf; *)
  (* crecip_3 out buf; *)
  (* let t0 = Buffer.sub buf 5ul  5ul in *)
  (* let t1 = Buffer.sub buf 0ul  5ul in *)
  (* fsquare t1 z; *)
  (* fmul out t0 t1; *)
  (* pop_frame() *)
