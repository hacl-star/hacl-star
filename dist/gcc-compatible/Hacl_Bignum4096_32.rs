#![allow(
    dead_code,
    mutable_transmutes,
    non_camel_case_types,
    non_snake_case,
    non_upper_case_globals,
    unused_assignments,
    unused_mut
)]
extern "C" {
    fn memcpy(
        _: *mut libc::c_void,
        _: *const libc::c_void,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn memset(
        _: *mut libc::c_void,
        _: libc::c_int,
        _: libc::c_ulong,
    ) -> *mut libc::c_void;
    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;
    fn exit(_: libc::c_int) -> !;
    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;
    fn calloc(_: libc::c_ulong, _: libc::c_ulong) -> *mut libc::c_void;
    fn free(_: *mut libc::c_void);
    fn Hacl_Bignum_Karatsuba_bn_karatsuba_mul_uint32(
        aLen: uint32_t,
        a: *mut uint32_t,
        b: *mut uint32_t,
        tmp: *mut uint32_t,
        res: *mut uint32_t,
    );
    fn Hacl_Bignum_Karatsuba_bn_karatsuba_sqr_uint32(
        aLen: uint32_t,
        a: *mut uint32_t,
        tmp: *mut uint32_t,
        res: *mut uint32_t,
    );
    fn Hacl_Bignum_ModInvLimb_mod_inv_uint32(n0: uint32_t) -> uint32_t;
}
pub type __uint32_t = libc::c_uint;
pub type __darwin_size_t = libc::c_ulong;
pub type size_t = __darwin_size_t;
pub type uint8_t = libc::c_uchar;
pub type uint32_t = libc::c_uint;
pub type uint64_t = libc::c_ulonglong;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Hacl_Bignum_MontArithmetic_bn_mont_ctx_u32_s {
    pub len: uint32_t,
    pub n: *mut uint32_t,
    pub mu: uint32_t,
    pub r2: *mut uint32_t,
}
pub type Hacl_Bignum_MontArithmetic_bn_mont_ctx_u32 = Hacl_Bignum_MontArithmetic_bn_mont_ctx_u32_s;
#[inline]
unsafe extern "C" fn _OSSwapInt32(mut _data: __uint32_t) -> __uint32_t {
    _data = _data.swap_bytes();
    return _data;
}
#[inline]
unsafe extern "C" fn load32(mut b: *mut uint8_t) -> uint32_t {
    let mut x: uint32_t = 0;
    memcpy(
        &mut x as *mut uint32_t as *mut libc::c_void,
        b as *const libc::c_void,
        4 as libc::c_int as libc::c_ulong,
    );
    return x;
}
#[inline]
unsafe extern "C" fn store32(mut b: *mut uint8_t, mut i: uint32_t) {
    memcpy(
        b as *mut libc::c_void,
        &mut i as *mut uint32_t as *const libc::c_void,
        4 as libc::c_int as libc::c_ulong,
    );
}
#[inline(never)]
unsafe extern "C" fn FStar_UInt32_eq_mask(mut a: uint32_t, mut b: uint32_t) -> uint32_t {
    let mut x: uint32_t = a ^ b;
    let mut minus_x: uint32_t = (!x).wrapping_add(1 as libc::c_uint);
    let mut x_or_minus_x: uint32_t = x | minus_x;
    let mut xnx: uint32_t = x_or_minus_x >> 31 as libc::c_uint;
    return xnx.wrapping_sub(1 as libc::c_uint);
}
#[inline(never)]
unsafe extern "C" fn FStar_UInt32_gte_mask(
    mut a: uint32_t,
    mut b: uint32_t,
) -> uint32_t {
    let mut x: uint32_t = a;
    let mut y: uint32_t = b;
    let mut x_xor_y: uint32_t = x ^ y;
    let mut x_sub_y: uint32_t = x.wrapping_sub(y);
    let mut x_sub_y_xor_y: uint32_t = x_sub_y ^ y;
    let mut q: uint32_t = x_xor_y | x_sub_y_xor_y;
    let mut x_xor_q: uint32_t = x ^ q;
    let mut x_xor_q_: uint32_t = x_xor_q >> 31 as libc::c_uint;
    return x_xor_q_.wrapping_sub(1 as libc::c_uint);
}
#[inline]
unsafe extern "C" fn Hacl_IntTypes_Intrinsics_add_carry_u32(
    mut cin: uint32_t,
    mut x: uint32_t,
    mut y: uint32_t,
    mut r: *mut uint32_t,
) -> uint32_t {
    let mut res: uint64_t = (x as uint64_t)
        .wrapping_add(cin as uint64_t)
        .wrapping_add(y as uint64_t);
    let mut c: uint32_t = (res >> 32 as libc::c_uint) as uint32_t;
    *r.offset(0 as libc::c_uint as isize) = res as uint32_t;
    return c;
}
#[inline]
unsafe extern "C" fn Hacl_IntTypes_Intrinsics_sub_borrow_u32(
    mut cin: uint32_t,
    mut x: uint32_t,
    mut y: uint32_t,
    mut r: *mut uint32_t,
) -> uint32_t {
    let mut res: uint64_t = (x as uint64_t)
        .wrapping_sub(y as uint64_t)
        .wrapping_sub(cin as uint64_t);
    let mut c: uint32_t = (res >> 32 as libc::c_uint) as uint32_t & 1 as libc::c_uint;
    *r.offset(0 as libc::c_uint as isize) = res as uint32_t;
    return c;
}
#[inline]
unsafe extern "C" fn Hacl_Bignum_Base_mul_wide_add2_u32(
    mut a: uint32_t,
    mut b: uint32_t,
    mut c_in: uint32_t,
    mut out: *mut uint32_t,
) -> uint32_t {
    let mut out0: uint32_t = *out.offset(0 as libc::c_uint as isize);
    let mut res: uint64_t = (a as uint64_t * b as uint64_t)
        .wrapping_add(c_in as uint64_t)
        .wrapping_add(out0 as uint64_t);
    *out.offset(0 as libc::c_uint as isize) = res as uint32_t;
    return (res >> 32 as libc::c_uint) as uint32_t;
}
#[inline]
unsafe extern "C" fn Hacl_Bignum_Lib_bn_get_top_index_u32(
    mut len: uint32_t,
    mut b: *mut uint32_t,
) -> uint32_t {
    let mut priv_0: uint32_t = 0 as libc::c_uint;
    let mut i: uint32_t = 0 as libc::c_uint;
    while i < len {
        let mut mask: uint32_t = FStar_UInt32_eq_mask(
            *b.offset(i as isize),
            0 as libc::c_uint,
        );
        priv_0 = mask & priv_0 | !mask & i;
        i = i.wrapping_add(1);
        i;
    }
    return priv_0;
}
#[inline]
unsafe extern "C" fn Hacl_Bignum_Lib_bn_get_bits_u32(
    mut len: uint32_t,
    mut b: *mut uint32_t,
    mut i: uint32_t,
    mut l: uint32_t,
) -> uint32_t {
    let mut i1: uint32_t = i.wrapping_div(32 as libc::c_uint);
    let mut j: uint32_t = i.wrapping_rem(32 as libc::c_uint);
    let mut p1: uint32_t = *b.offset(i1 as isize) >> j;
    let mut ite: uint32_t = 0;
    if i1.wrapping_add(1 as libc::c_uint) < len && (0 as libc::c_uint) < j {
        ite = p1
            | *b.offset(i1.wrapping_add(1 as libc::c_uint) as isize)
                << (32 as libc::c_uint).wrapping_sub(j);
    } else {
        ite = p1;
    }
    return ite & ((1 as libc::c_uint) << l).wrapping_sub(1 as libc::c_uint);
}
#[no_mangle]
pub unsafe extern "C" fn Hacl_Bignum4096_32_add(
    mut a: *mut uint32_t,
    mut b: *mut uint32_t,
    mut res: *mut uint32_t,
) -> uint32_t {
    let mut c: uint32_t = 0 as libc::c_uint;
    let mut i: uint32_t = 0 as libc::c_uint;
    while i < 32 as libc::c_uint {
        let mut t1: uint32_t = *a.offset((4 as libc::c_uint).wrapping_mul(i) as isize);
        let mut t20: uint32_t = *b.offset((4 as libc::c_uint).wrapping_mul(i) as isize);
        let mut res_i0: *mut uint32_t = res
            .offset((4 as libc::c_uint).wrapping_mul(i) as isize);
        c = Hacl_IntTypes_Intrinsics_add_carry_u32(c, t1, t20, res_i0);
        let mut t10: uint32_t = *a
            .offset(
                (4 as libc::c_uint).wrapping_mul(i).wrapping_add(1 as libc::c_uint)
                    as isize,
            );
        let mut t21: uint32_t = *b
            .offset(
                (4 as libc::c_uint).wrapping_mul(i).wrapping_add(1 as libc::c_uint)
                    as isize,
            );
        let mut res_i1: *mut uint32_t = res
            .offset((4 as libc::c_uint).wrapping_mul(i) as isize)
            .offset(1 as libc::c_uint as isize);
        c = Hacl_IntTypes_Intrinsics_add_carry_u32(c, t10, t21, res_i1);
        let mut t11: uint32_t = *a
            .offset(
                (4 as libc::c_uint).wrapping_mul(i).wrapping_add(2 as libc::c_uint)
                    as isize,
            );
        let mut t22: uint32_t = *b
            .offset(
                (4 as libc::c_uint).wrapping_mul(i).wrapping_add(2 as libc::c_uint)
                    as isize,
            );
        let mut res_i2: *mut uint32_t = res
            .offset((4 as libc::c_uint).wrapping_mul(i) as isize)
            .offset(2 as libc::c_uint as isize);
        c = Hacl_IntTypes_Intrinsics_add_carry_u32(c, t11, t22, res_i2);
        let mut t12: uint32_t = *a
            .offset(
                (4 as libc::c_uint).wrapping_mul(i).wrapping_add(3 as libc::c_uint)
                    as isize,
            );
        let mut t2: uint32_t = *b
            .offset(
                (4 as libc::c_uint).wrapping_mul(i).wrapping_add(3 as libc::c_uint)
                    as isize,
            );
        let mut res_i: *mut uint32_t = res
            .offset((4 as libc::c_uint).wrapping_mul(i) as isize)
            .offset(3 as libc::c_uint as isize);
        c = Hacl_IntTypes_Intrinsics_add_carry_u32(c, t12, t2, res_i);
        i = i.wrapping_add(1);
        i;
    }
    return c;
}
#[no_mangle]
pub unsafe extern "C" fn Hacl_Bignum4096_32_sub(
    mut a: *mut uint32_t,
    mut b: *mut uint32_t,
    mut res: *mut uint32_t,
) -> uint32_t {
    let mut c: uint32_t = 0 as libc::c_uint;
    let mut i: uint32_t = 0 as libc::c_uint;
    while i < 32 as libc::c_uint {
        let mut t1: uint32_t = *a.offset((4 as libc::c_uint).wrapping_mul(i) as isize);
        let mut t20: uint32_t = *b.offset((4 as libc::c_uint).wrapping_mul(i) as isize);
        let mut res_i0: *mut uint32_t = res
            .offset((4 as libc::c_uint).wrapping_mul(i) as isize);
        c = Hacl_IntTypes_Intrinsics_sub_borrow_u32(c, t1, t20, res_i0);
        let mut t10: uint32_t = *a
            .offset(
                (4 as libc::c_uint).wrapping_mul(i).wrapping_add(1 as libc::c_uint)
                    as isize,
            );
        let mut t21: uint32_t = *b
            .offset(
                (4 as libc::c_uint).wrapping_mul(i).wrapping_add(1 as libc::c_uint)
                    as isize,
            );
        let mut res_i1: *mut uint32_t = res
            .offset((4 as libc::c_uint).wrapping_mul(i) as isize)
            .offset(1 as libc::c_uint as isize);
        c = Hacl_IntTypes_Intrinsics_sub_borrow_u32(c, t10, t21, res_i1);
        let mut t11: uint32_t = *a
            .offset(
                (4 as libc::c_uint).wrapping_mul(i).wrapping_add(2 as libc::c_uint)
                    as isize,
            );
        let mut t22: uint32_t = *b
            .offset(
                (4 as libc::c_uint).wrapping_mul(i).wrapping_add(2 as libc::c_uint)
                    as isize,
            );
        let mut res_i2: *mut uint32_t = res
            .offset((4 as libc::c_uint).wrapping_mul(i) as isize)
            .offset(2 as libc::c_uint as isize);
        c = Hacl_IntTypes_Intrinsics_sub_borrow_u32(c, t11, t22, res_i2);
        let mut t12: uint32_t = *a
            .offset(
                (4 as libc::c_uint).wrapping_mul(i).wrapping_add(3 as libc::c_uint)
                    as isize,
            );
        let mut t2: uint32_t = *b
            .offset(
                (4 as libc::c_uint).wrapping_mul(i).wrapping_add(3 as libc::c_uint)
                    as isize,
            );
        let mut res_i: *mut uint32_t = res
            .offset((4 as libc::c_uint).wrapping_mul(i) as isize)
            .offset(3 as libc::c_uint as isize);
        c = Hacl_IntTypes_Intrinsics_sub_borrow_u32(c, t12, t2, res_i);
        i = i.wrapping_add(1);
        i;
    }
    return c;
}
#[no_mangle]
pub unsafe extern "C" fn Hacl_Bignum4096_32_add_mod(
    mut n: *mut uint32_t,
    mut a: *mut uint32_t,
    mut b: *mut uint32_t,
    mut res: *mut uint32_t,
) {
    let mut c0: uint32_t = 0 as libc::c_uint;
    let mut i: uint32_t = 0 as libc::c_uint;
    while i < 32 as libc::c_uint {
        let mut t1: uint32_t = *a.offset((4 as libc::c_uint).wrapping_mul(i) as isize);
        let mut t20: uint32_t = *b.offset((4 as libc::c_uint).wrapping_mul(i) as isize);
        let mut res_i0: *mut uint32_t = res
            .offset((4 as libc::c_uint).wrapping_mul(i) as isize);
        c0 = Hacl_IntTypes_Intrinsics_add_carry_u32(c0, t1, t20, res_i0);
        let mut t10: uint32_t = *a
            .offset(
                (4 as libc::c_uint).wrapping_mul(i).wrapping_add(1 as libc::c_uint)
                    as isize,
            );
        let mut t21: uint32_t = *b
            .offset(
                (4 as libc::c_uint).wrapping_mul(i).wrapping_add(1 as libc::c_uint)
                    as isize,
            );
        let mut res_i1: *mut uint32_t = res
            .offset((4 as libc::c_uint).wrapping_mul(i) as isize)
            .offset(1 as libc::c_uint as isize);
        c0 = Hacl_IntTypes_Intrinsics_add_carry_u32(c0, t10, t21, res_i1);
        let mut t11: uint32_t = *a
            .offset(
                (4 as libc::c_uint).wrapping_mul(i).wrapping_add(2 as libc::c_uint)
                    as isize,
            );
        let mut t22: uint32_t = *b
            .offset(
                (4 as libc::c_uint).wrapping_mul(i).wrapping_add(2 as libc::c_uint)
                    as isize,
            );
        let mut res_i2: *mut uint32_t = res
            .offset((4 as libc::c_uint).wrapping_mul(i) as isize)
            .offset(2 as libc::c_uint as isize);
        c0 = Hacl_IntTypes_Intrinsics_add_carry_u32(c0, t11, t22, res_i2);
        let mut t12: uint32_t = *a
            .offset(
                (4 as libc::c_uint).wrapping_mul(i).wrapping_add(3 as libc::c_uint)
                    as isize,
            );
        let mut t2: uint32_t = *b
            .offset(
                (4 as libc::c_uint).wrapping_mul(i).wrapping_add(3 as libc::c_uint)
                    as isize,
            );
        let mut res_i: *mut uint32_t = res
            .offset((4 as libc::c_uint).wrapping_mul(i) as isize)
            .offset(3 as libc::c_uint as isize);
        c0 = Hacl_IntTypes_Intrinsics_add_carry_u32(c0, t12, t2, res_i);
        i = i.wrapping_add(1);
        i;
    }
    let mut c00: uint32_t = c0;
    let mut tmp: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    let mut c: uint32_t = 0 as libc::c_uint;
    let mut i_0: uint32_t = 0 as libc::c_uint;
    while i_0 < 32 as libc::c_uint {
        let mut t1_0: uint32_t = *res
            .offset((4 as libc::c_uint).wrapping_mul(i_0) as isize);
        let mut t20_0: uint32_t = *n
            .offset((4 as libc::c_uint).wrapping_mul(i_0) as isize);
        let mut res_i0_0: *mut uint32_t = tmp
            .as_mut_ptr()
            .offset((4 as libc::c_uint).wrapping_mul(i_0) as isize);
        c = Hacl_IntTypes_Intrinsics_sub_borrow_u32(c, t1_0, t20_0, res_i0_0);
        let mut t10_0: uint32_t = *res
            .offset(
                (4 as libc::c_uint).wrapping_mul(i_0).wrapping_add(1 as libc::c_uint)
                    as isize,
            );
        let mut t21_0: uint32_t = *n
            .offset(
                (4 as libc::c_uint).wrapping_mul(i_0).wrapping_add(1 as libc::c_uint)
                    as isize,
            );
        let mut res_i1_0: *mut uint32_t = tmp
            .as_mut_ptr()
            .offset((4 as libc::c_uint).wrapping_mul(i_0) as isize)
            .offset(1 as libc::c_uint as isize);
        c = Hacl_IntTypes_Intrinsics_sub_borrow_u32(c, t10_0, t21_0, res_i1_0);
        let mut t11_0: uint32_t = *res
            .offset(
                (4 as libc::c_uint).wrapping_mul(i_0).wrapping_add(2 as libc::c_uint)
                    as isize,
            );
        let mut t22_0: uint32_t = *n
            .offset(
                (4 as libc::c_uint).wrapping_mul(i_0).wrapping_add(2 as libc::c_uint)
                    as isize,
            );
        let mut res_i2_0: *mut uint32_t = tmp
            .as_mut_ptr()
            .offset((4 as libc::c_uint).wrapping_mul(i_0) as isize)
            .offset(2 as libc::c_uint as isize);
        c = Hacl_IntTypes_Intrinsics_sub_borrow_u32(c, t11_0, t22_0, res_i2_0);
        let mut t12_0: uint32_t = *res
            .offset(
                (4 as libc::c_uint).wrapping_mul(i_0).wrapping_add(3 as libc::c_uint)
                    as isize,
            );
        let mut t2_0: uint32_t = *n
            .offset(
                (4 as libc::c_uint).wrapping_mul(i_0).wrapping_add(3 as libc::c_uint)
                    as isize,
            );
        let mut res_i_0: *mut uint32_t = tmp
            .as_mut_ptr()
            .offset((4 as libc::c_uint).wrapping_mul(i_0) as isize)
            .offset(3 as libc::c_uint as isize);
        c = Hacl_IntTypes_Intrinsics_sub_borrow_u32(c, t12_0, t2_0, res_i_0);
        i_0 = i_0.wrapping_add(1);
        i_0;
    }
    let mut c1: uint32_t = c;
    let mut c2: uint32_t = c00.wrapping_sub(c1);
    let mut i_1: uint32_t = 0 as libc::c_uint;
    while i_1 < 128 as libc::c_uint {
        let mut x: uint32_t = c2 & *res.offset(i_1 as isize) | !c2 & tmp[i_1 as usize];
        let mut os: *mut uint32_t = res;
        *os.offset(i_1 as isize) = x;
        i_1 = i_1.wrapping_add(1);
        i_1;
    }
}
#[no_mangle]
pub unsafe extern "C" fn Hacl_Bignum4096_32_sub_mod(
    mut n: *mut uint32_t,
    mut a: *mut uint32_t,
    mut b: *mut uint32_t,
    mut res: *mut uint32_t,
) {
    let mut c0: uint32_t = 0 as libc::c_uint;
    let mut i: uint32_t = 0 as libc::c_uint;
    while i < 32 as libc::c_uint {
        let mut t1: uint32_t = *a.offset((4 as libc::c_uint).wrapping_mul(i) as isize);
        let mut t20: uint32_t = *b.offset((4 as libc::c_uint).wrapping_mul(i) as isize);
        let mut res_i0: *mut uint32_t = res
            .offset((4 as libc::c_uint).wrapping_mul(i) as isize);
        c0 = Hacl_IntTypes_Intrinsics_sub_borrow_u32(c0, t1, t20, res_i0);
        let mut t10: uint32_t = *a
            .offset(
                (4 as libc::c_uint).wrapping_mul(i).wrapping_add(1 as libc::c_uint)
                    as isize,
            );
        let mut t21: uint32_t = *b
            .offset(
                (4 as libc::c_uint).wrapping_mul(i).wrapping_add(1 as libc::c_uint)
                    as isize,
            );
        let mut res_i1: *mut uint32_t = res
            .offset((4 as libc::c_uint).wrapping_mul(i) as isize)
            .offset(1 as libc::c_uint as isize);
        c0 = Hacl_IntTypes_Intrinsics_sub_borrow_u32(c0, t10, t21, res_i1);
        let mut t11: uint32_t = *a
            .offset(
                (4 as libc::c_uint).wrapping_mul(i).wrapping_add(2 as libc::c_uint)
                    as isize,
            );
        let mut t22: uint32_t = *b
            .offset(
                (4 as libc::c_uint).wrapping_mul(i).wrapping_add(2 as libc::c_uint)
                    as isize,
            );
        let mut res_i2: *mut uint32_t = res
            .offset((4 as libc::c_uint).wrapping_mul(i) as isize)
            .offset(2 as libc::c_uint as isize);
        c0 = Hacl_IntTypes_Intrinsics_sub_borrow_u32(c0, t11, t22, res_i2);
        let mut t12: uint32_t = *a
            .offset(
                (4 as libc::c_uint).wrapping_mul(i).wrapping_add(3 as libc::c_uint)
                    as isize,
            );
        let mut t2: uint32_t = *b
            .offset(
                (4 as libc::c_uint).wrapping_mul(i).wrapping_add(3 as libc::c_uint)
                    as isize,
            );
        let mut res_i: *mut uint32_t = res
            .offset((4 as libc::c_uint).wrapping_mul(i) as isize)
            .offset(3 as libc::c_uint as isize);
        c0 = Hacl_IntTypes_Intrinsics_sub_borrow_u32(c0, t12, t2, res_i);
        i = i.wrapping_add(1);
        i;
    }
    let mut c00: uint32_t = c0;
    let mut tmp: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    let mut c: uint32_t = 0 as libc::c_uint;
    let mut i_0: uint32_t = 0 as libc::c_uint;
    while i_0 < 32 as libc::c_uint {
        let mut t1_0: uint32_t = *res
            .offset((4 as libc::c_uint).wrapping_mul(i_0) as isize);
        let mut t20_0: uint32_t = *n
            .offset((4 as libc::c_uint).wrapping_mul(i_0) as isize);
        let mut res_i0_0: *mut uint32_t = tmp
            .as_mut_ptr()
            .offset((4 as libc::c_uint).wrapping_mul(i_0) as isize);
        c = Hacl_IntTypes_Intrinsics_add_carry_u32(c, t1_0, t20_0, res_i0_0);
        let mut t10_0: uint32_t = *res
            .offset(
                (4 as libc::c_uint).wrapping_mul(i_0).wrapping_add(1 as libc::c_uint)
                    as isize,
            );
        let mut t21_0: uint32_t = *n
            .offset(
                (4 as libc::c_uint).wrapping_mul(i_0).wrapping_add(1 as libc::c_uint)
                    as isize,
            );
        let mut res_i1_0: *mut uint32_t = tmp
            .as_mut_ptr()
            .offset((4 as libc::c_uint).wrapping_mul(i_0) as isize)
            .offset(1 as libc::c_uint as isize);
        c = Hacl_IntTypes_Intrinsics_add_carry_u32(c, t10_0, t21_0, res_i1_0);
        let mut t11_0: uint32_t = *res
            .offset(
                (4 as libc::c_uint).wrapping_mul(i_0).wrapping_add(2 as libc::c_uint)
                    as isize,
            );
        let mut t22_0: uint32_t = *n
            .offset(
                (4 as libc::c_uint).wrapping_mul(i_0).wrapping_add(2 as libc::c_uint)
                    as isize,
            );
        let mut res_i2_0: *mut uint32_t = tmp
            .as_mut_ptr()
            .offset((4 as libc::c_uint).wrapping_mul(i_0) as isize)
            .offset(2 as libc::c_uint as isize);
        c = Hacl_IntTypes_Intrinsics_add_carry_u32(c, t11_0, t22_0, res_i2_0);
        let mut t12_0: uint32_t = *res
            .offset(
                (4 as libc::c_uint).wrapping_mul(i_0).wrapping_add(3 as libc::c_uint)
                    as isize,
            );
        let mut t2_0: uint32_t = *n
            .offset(
                (4 as libc::c_uint).wrapping_mul(i_0).wrapping_add(3 as libc::c_uint)
                    as isize,
            );
        let mut res_i_0: *mut uint32_t = tmp
            .as_mut_ptr()
            .offset((4 as libc::c_uint).wrapping_mul(i_0) as isize)
            .offset(3 as libc::c_uint as isize);
        c = Hacl_IntTypes_Intrinsics_add_carry_u32(c, t12_0, t2_0, res_i_0);
        i_0 = i_0.wrapping_add(1);
        i_0;
    }
    let mut c1: uint32_t = c;
    let mut c2: uint32_t = (0 as libc::c_uint).wrapping_sub(c00);
    let mut i_1: uint32_t = 0 as libc::c_uint;
    while i_1 < 128 as libc::c_uint {
        let mut x: uint32_t = c2 & tmp[i_1 as usize] | !c2 & *res.offset(i_1 as isize);
        let mut os: *mut uint32_t = res;
        *os.offset(i_1 as isize) = x;
        i_1 = i_1.wrapping_add(1);
        i_1;
    }
}
#[no_mangle]
pub unsafe extern "C" fn Hacl_Bignum4096_32_mul(
    mut a: *mut uint32_t,
    mut b: *mut uint32_t,
    mut res: *mut uint32_t,
) {
    let mut tmp: [uint32_t; 512] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    Hacl_Bignum_Karatsuba_bn_karatsuba_mul_uint32(
        128 as libc::c_uint,
        a,
        b,
        tmp.as_mut_ptr(),
        res,
    );
}
#[no_mangle]
pub unsafe extern "C" fn Hacl_Bignum4096_32_sqr(
    mut a: *mut uint32_t,
    mut res: *mut uint32_t,
) {
    let mut tmp: [uint32_t; 512] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    Hacl_Bignum_Karatsuba_bn_karatsuba_sqr_uint32(
        128 as libc::c_uint,
        a,
        tmp.as_mut_ptr(),
        res,
    );
}
#[inline]
unsafe extern "C" fn precompr2(
    mut nBits: uint32_t,
    mut n: *mut uint32_t,
    mut res: *mut uint32_t,
) {
    memset(
        res as *mut libc::c_void,
        0 as libc::c_uint as libc::c_int,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut i: uint32_t = nBits.wrapping_div(32 as libc::c_uint);
    let mut j: uint32_t = nBits.wrapping_rem(32 as libc::c_uint);
    *res.offset(i as isize) = *res.offset(i as isize) | (1 as libc::c_uint) << j;
    let mut i0: uint32_t = 0 as libc::c_uint;
    while i0 < (8192 as libc::c_uint).wrapping_sub(nBits) {
        let mut a_copy: [uint32_t; 128] = [
            0 as libc::c_uint,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
        ];
        let mut b_copy: [uint32_t; 128] = [
            0 as libc::c_uint,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
        ];
        memcpy(
            a_copy.as_mut_ptr() as *mut libc::c_void,
            res as *const libc::c_void,
            (128 as libc::c_uint as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
        );
        memcpy(
            b_copy.as_mut_ptr() as *mut libc::c_void,
            res as *const libc::c_void,
            (128 as libc::c_uint as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
        );
        Hacl_Bignum4096_32_add_mod(n, a_copy.as_mut_ptr(), b_copy.as_mut_ptr(), res);
        i0 = i0.wrapping_add(1);
        i0;
    }
}
#[inline]
unsafe extern "C" fn reduction(
    mut n: *mut uint32_t,
    mut nInv: uint32_t,
    mut c: *mut uint32_t,
    mut res: *mut uint32_t,
) {
    let mut c0: uint32_t = 0 as libc::c_uint;
    let mut i0: uint32_t = 0 as libc::c_uint;
    while i0 < 128 as libc::c_uint {
        let mut qj: uint32_t = nInv * *c.offset(i0 as isize);
        let mut res_j0: *mut uint32_t = c.offset(i0 as isize);
        let mut c1: uint32_t = 0 as libc::c_uint;
        let mut i: uint32_t = 0 as libc::c_uint;
        while i < 32 as libc::c_uint {
            let mut a_i: uint32_t = *n
                .offset((4 as libc::c_uint).wrapping_mul(i) as isize);
            let mut res_i0: *mut uint32_t = res_j0
                .offset((4 as libc::c_uint).wrapping_mul(i) as isize);
            c1 = Hacl_Bignum_Base_mul_wide_add2_u32(a_i, qj, c1, res_i0);
            let mut a_i0: uint32_t = *n
                .offset(
                    (4 as libc::c_uint).wrapping_mul(i).wrapping_add(1 as libc::c_uint)
                        as isize,
                );
            let mut res_i1: *mut uint32_t = res_j0
                .offset((4 as libc::c_uint).wrapping_mul(i) as isize)
                .offset(1 as libc::c_uint as isize);
            c1 = Hacl_Bignum_Base_mul_wide_add2_u32(a_i0, qj, c1, res_i1);
            let mut a_i1: uint32_t = *n
                .offset(
                    (4 as libc::c_uint).wrapping_mul(i).wrapping_add(2 as libc::c_uint)
                        as isize,
                );
            let mut res_i2: *mut uint32_t = res_j0
                .offset((4 as libc::c_uint).wrapping_mul(i) as isize)
                .offset(2 as libc::c_uint as isize);
            c1 = Hacl_Bignum_Base_mul_wide_add2_u32(a_i1, qj, c1, res_i2);
            let mut a_i2: uint32_t = *n
                .offset(
                    (4 as libc::c_uint).wrapping_mul(i).wrapping_add(3 as libc::c_uint)
                        as isize,
                );
            let mut res_i: *mut uint32_t = res_j0
                .offset((4 as libc::c_uint).wrapping_mul(i) as isize)
                .offset(3 as libc::c_uint as isize);
            c1 = Hacl_Bignum_Base_mul_wide_add2_u32(a_i2, qj, c1, res_i);
            i = i.wrapping_add(1);
            i;
        }
        let mut r: uint32_t = c1;
        let mut c10: uint32_t = r;
        let mut res_j: uint32_t = *c
            .offset((128 as libc::c_uint).wrapping_add(i0) as isize);
        let mut resb: *mut uint32_t = c
            .offset(128 as libc::c_uint as isize)
            .offset(i0 as isize);
        c0 = Hacl_IntTypes_Intrinsics_add_carry_u32(c0, c10, res_j, resb);
        i0 = i0.wrapping_add(1);
        i0;
    }
    memcpy(
        res as *mut libc::c_void,
        c.offset(128 as libc::c_uint as isize) as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut c00: uint32_t = c0;
    let mut tmp: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    let mut c1_0: uint32_t = 0 as libc::c_uint;
    let mut i_0: uint32_t = 0 as libc::c_uint;
    while i_0 < 32 as libc::c_uint {
        let mut t1: uint32_t = *res
            .offset((4 as libc::c_uint).wrapping_mul(i_0) as isize);
        let mut t20: uint32_t = *n
            .offset((4 as libc::c_uint).wrapping_mul(i_0) as isize);
        let mut res_i0_0: *mut uint32_t = tmp
            .as_mut_ptr()
            .offset((4 as libc::c_uint).wrapping_mul(i_0) as isize);
        c1_0 = Hacl_IntTypes_Intrinsics_sub_borrow_u32(c1_0, t1, t20, res_i0_0);
        let mut t10: uint32_t = *res
            .offset(
                (4 as libc::c_uint).wrapping_mul(i_0).wrapping_add(1 as libc::c_uint)
                    as isize,
            );
        let mut t21: uint32_t = *n
            .offset(
                (4 as libc::c_uint).wrapping_mul(i_0).wrapping_add(1 as libc::c_uint)
                    as isize,
            );
        let mut res_i1_0: *mut uint32_t = tmp
            .as_mut_ptr()
            .offset((4 as libc::c_uint).wrapping_mul(i_0) as isize)
            .offset(1 as libc::c_uint as isize);
        c1_0 = Hacl_IntTypes_Intrinsics_sub_borrow_u32(c1_0, t10, t21, res_i1_0);
        let mut t11: uint32_t = *res
            .offset(
                (4 as libc::c_uint).wrapping_mul(i_0).wrapping_add(2 as libc::c_uint)
                    as isize,
            );
        let mut t22: uint32_t = *n
            .offset(
                (4 as libc::c_uint).wrapping_mul(i_0).wrapping_add(2 as libc::c_uint)
                    as isize,
            );
        let mut res_i2_0: *mut uint32_t = tmp
            .as_mut_ptr()
            .offset((4 as libc::c_uint).wrapping_mul(i_0) as isize)
            .offset(2 as libc::c_uint as isize);
        c1_0 = Hacl_IntTypes_Intrinsics_sub_borrow_u32(c1_0, t11, t22, res_i2_0);
        let mut t12: uint32_t = *res
            .offset(
                (4 as libc::c_uint).wrapping_mul(i_0).wrapping_add(3 as libc::c_uint)
                    as isize,
            );
        let mut t2: uint32_t = *n
            .offset(
                (4 as libc::c_uint).wrapping_mul(i_0).wrapping_add(3 as libc::c_uint)
                    as isize,
            );
        let mut res_i_0: *mut uint32_t = tmp
            .as_mut_ptr()
            .offset((4 as libc::c_uint).wrapping_mul(i_0) as isize)
            .offset(3 as libc::c_uint as isize);
        c1_0 = Hacl_IntTypes_Intrinsics_sub_borrow_u32(c1_0, t12, t2, res_i_0);
        i_0 = i_0.wrapping_add(1);
        i_0;
    }
    let mut c10_0: uint32_t = c1_0;
    let mut c2: uint32_t = c00.wrapping_sub(c10_0);
    let mut i_1: uint32_t = 0 as libc::c_uint;
    while i_1 < 128 as libc::c_uint {
        let mut x: uint32_t = c2 & *res.offset(i_1 as isize) | !c2 & tmp[i_1 as usize];
        let mut os: *mut uint32_t = res;
        *os.offset(i_1 as isize) = x;
        i_1 = i_1.wrapping_add(1);
        i_1;
    }
}
#[inline]
unsafe extern "C" fn to(
    mut n: *mut uint32_t,
    mut nInv: uint32_t,
    mut r2: *mut uint32_t,
    mut a: *mut uint32_t,
    mut aM: *mut uint32_t,
) {
    let mut c: [uint32_t; 256] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    Hacl_Bignum4096_32_mul(a, r2, c.as_mut_ptr());
    reduction(n, nInv, c.as_mut_ptr(), aM);
}
#[inline]
unsafe extern "C" fn from(
    mut n: *mut uint32_t,
    mut nInv_u64: uint32_t,
    mut aM: *mut uint32_t,
    mut a: *mut uint32_t,
) {
    let mut tmp: [uint32_t; 256] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    memcpy(
        tmp.as_mut_ptr() as *mut libc::c_void,
        aM as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    reduction(n, nInv_u64, tmp.as_mut_ptr(), a);
}
#[inline]
unsafe extern "C" fn areduction(
    mut n: *mut uint32_t,
    mut nInv: uint32_t,
    mut c: *mut uint32_t,
    mut res: *mut uint32_t,
) {
    let mut c0: uint32_t = 0 as libc::c_uint;
    let mut i0: uint32_t = 0 as libc::c_uint;
    while i0 < 128 as libc::c_uint {
        let mut qj: uint32_t = nInv * *c.offset(i0 as isize);
        let mut res_j0: *mut uint32_t = c.offset(i0 as isize);
        let mut c1: uint32_t = 0 as libc::c_uint;
        let mut i: uint32_t = 0 as libc::c_uint;
        while i < 32 as libc::c_uint {
            let mut a_i: uint32_t = *n
                .offset((4 as libc::c_uint).wrapping_mul(i) as isize);
            let mut res_i0: *mut uint32_t = res_j0
                .offset((4 as libc::c_uint).wrapping_mul(i) as isize);
            c1 = Hacl_Bignum_Base_mul_wide_add2_u32(a_i, qj, c1, res_i0);
            let mut a_i0: uint32_t = *n
                .offset(
                    (4 as libc::c_uint).wrapping_mul(i).wrapping_add(1 as libc::c_uint)
                        as isize,
                );
            let mut res_i1: *mut uint32_t = res_j0
                .offset((4 as libc::c_uint).wrapping_mul(i) as isize)
                .offset(1 as libc::c_uint as isize);
            c1 = Hacl_Bignum_Base_mul_wide_add2_u32(a_i0, qj, c1, res_i1);
            let mut a_i1: uint32_t = *n
                .offset(
                    (4 as libc::c_uint).wrapping_mul(i).wrapping_add(2 as libc::c_uint)
                        as isize,
                );
            let mut res_i2: *mut uint32_t = res_j0
                .offset((4 as libc::c_uint).wrapping_mul(i) as isize)
                .offset(2 as libc::c_uint as isize);
            c1 = Hacl_Bignum_Base_mul_wide_add2_u32(a_i1, qj, c1, res_i2);
            let mut a_i2: uint32_t = *n
                .offset(
                    (4 as libc::c_uint).wrapping_mul(i).wrapping_add(3 as libc::c_uint)
                        as isize,
                );
            let mut res_i: *mut uint32_t = res_j0
                .offset((4 as libc::c_uint).wrapping_mul(i) as isize)
                .offset(3 as libc::c_uint as isize);
            c1 = Hacl_Bignum_Base_mul_wide_add2_u32(a_i2, qj, c1, res_i);
            i = i.wrapping_add(1);
            i;
        }
        let mut r: uint32_t = c1;
        let mut c10: uint32_t = r;
        let mut res_j: uint32_t = *c
            .offset((128 as libc::c_uint).wrapping_add(i0) as isize);
        let mut resb: *mut uint32_t = c
            .offset(128 as libc::c_uint as isize)
            .offset(i0 as isize);
        c0 = Hacl_IntTypes_Intrinsics_add_carry_u32(c0, c10, res_j, resb);
        i0 = i0.wrapping_add(1);
        i0;
    }
    memcpy(
        res as *mut libc::c_void,
        c.offset(128 as libc::c_uint as isize) as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut c00: uint32_t = c0;
    let mut tmp: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    let mut c1_0: uint32_t = Hacl_Bignum4096_32_sub(res, n, tmp.as_mut_ptr());
    let mut m: uint32_t = (0 as libc::c_uint).wrapping_sub(c00);
    let mut i_0: uint32_t = 0 as libc::c_uint;
    while i_0 < 128 as libc::c_uint {
        let mut x: uint32_t = m & tmp[i_0 as usize] | !m & *res.offset(i_0 as isize);
        let mut os: *mut uint32_t = res;
        *os.offset(i_0 as isize) = x;
        i_0 = i_0.wrapping_add(1);
        i_0;
    }
}
#[inline]
unsafe extern "C" fn amont_mul(
    mut n: *mut uint32_t,
    mut nInv_u64: uint32_t,
    mut aM: *mut uint32_t,
    mut bM: *mut uint32_t,
    mut resM: *mut uint32_t,
) {
    let mut c: [uint32_t; 256] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    Hacl_Bignum4096_32_mul(aM, bM, c.as_mut_ptr());
    areduction(n, nInv_u64, c.as_mut_ptr(), resM);
}
#[inline]
unsafe extern "C" fn amont_sqr(
    mut n: *mut uint32_t,
    mut nInv_u64: uint32_t,
    mut aM: *mut uint32_t,
    mut resM: *mut uint32_t,
) {
    let mut c: [uint32_t; 256] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    Hacl_Bignum4096_32_sqr(aM, c.as_mut_ptr());
    areduction(n, nInv_u64, c.as_mut_ptr(), resM);
}
#[inline]
unsafe extern "C" fn bn_slow_precomp(
    mut n: *mut uint32_t,
    mut mu: uint32_t,
    mut r2: *mut uint32_t,
    mut a: *mut uint32_t,
    mut res: *mut uint32_t,
) {
    let mut a_mod: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    let mut a1: [uint32_t; 256] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    memcpy(
        a1.as_mut_ptr() as *mut libc::c_void,
        a as *const libc::c_void,
        (256 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    areduction(n, mu, a1.as_mut_ptr(), a_mod.as_mut_ptr());
    to(n, mu, r2, a_mod.as_mut_ptr(), res);
}
#[no_mangle]
pub unsafe extern "C" fn Hacl_Bignum4096_32_mod(
    mut n: *mut uint32_t,
    mut a: *mut uint32_t,
    mut res: *mut uint32_t,
) -> bool {
    let mut one: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    memset(
        one.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_uint as libc::c_int,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    one[0 as libc::c_uint as usize] = 1 as libc::c_uint;
    let mut bit0: uint32_t = *n.offset(0 as libc::c_uint as isize) & 1 as libc::c_uint;
    let mut m0: uint32_t = (0 as libc::c_uint).wrapping_sub(bit0);
    let mut acc: uint32_t = 0 as libc::c_uint;
    let mut i: uint32_t = 0 as libc::c_uint;
    while i < 128 as libc::c_uint {
        let mut beq: uint32_t = FStar_UInt32_eq_mask(
            one[i as usize],
            *n.offset(i as isize),
        );
        let mut blt: uint32_t = !FStar_UInt32_gte_mask(
            one[i as usize],
            *n.offset(i as isize),
        );
        acc = beq & acc | !beq & blt;
        i = i.wrapping_add(1);
        i;
    }
    let mut m1: uint32_t = acc;
    let mut is_valid_m: uint32_t = m0 & m1;
    let mut nBits: uint32_t = (32 as libc::c_uint)
        .wrapping_mul(Hacl_Bignum_Lib_bn_get_top_index_u32(128 as libc::c_uint, n));
    if is_valid_m == 0xffffffff as libc::c_uint {
        let mut r2: [uint32_t; 128] = [
            0 as libc::c_uint,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
        ];
        precompr2(nBits, n, r2.as_mut_ptr());
        let mut mu: uint32_t = Hacl_Bignum_ModInvLimb_mod_inv_uint32(
            *n.offset(0 as libc::c_uint as isize),
        );
        bn_slow_precomp(n, mu, r2.as_mut_ptr(), a, res);
    } else {
        memset(
            res as *mut libc::c_void,
            0 as libc::c_uint as libc::c_int,
            (128 as libc::c_uint as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
        );
    }
    return is_valid_m == 0xffffffff as libc::c_uint;
}
unsafe extern "C" fn exp_check(
    mut n: *mut uint32_t,
    mut a: *mut uint32_t,
    mut bBits: uint32_t,
    mut b: *mut uint32_t,
) -> uint32_t {
    let mut one: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    memset(
        one.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_uint as libc::c_int,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    one[0 as libc::c_uint as usize] = 1 as libc::c_uint;
    let mut bit0: uint32_t = *n.offset(0 as libc::c_uint as isize) & 1 as libc::c_uint;
    let mut m0: uint32_t = (0 as libc::c_uint).wrapping_sub(bit0);
    let mut acc0: uint32_t = 0 as libc::c_uint;
    let mut i: uint32_t = 0 as libc::c_uint;
    while i < 128 as libc::c_uint {
        let mut beq: uint32_t = FStar_UInt32_eq_mask(
            one[i as usize],
            *n.offset(i as isize),
        );
        let mut blt: uint32_t = !FStar_UInt32_gte_mask(
            one[i as usize],
            *n.offset(i as isize),
        );
        acc0 = beq & acc0 | !beq & blt;
        i = i.wrapping_add(1);
        i;
    }
    let mut m10: uint32_t = acc0;
    let mut m00: uint32_t = m0 & m10;
    let mut bLen: uint32_t = 0;
    if bBits == 0 as libc::c_uint {
        bLen = 1 as libc::c_uint;
    } else {
        bLen = bBits
            .wrapping_sub(1 as libc::c_uint)
            .wrapping_div(32 as libc::c_uint)
            .wrapping_add(1 as libc::c_uint);
    }
    let mut m1: uint32_t = 0;
    if bBits < (32 as libc::c_uint).wrapping_mul(bLen) {
        if bLen as size_t
            > (18446744073709551615 as libc::c_ulong)
                .wrapping_div(::core::mem::size_of::<uint32_t>() as libc::c_ulong)
        {
            printf(
                b"Maximum allocatable size exceeded, aborting before overflow at %s:%d\n\0"
                    as *const u8 as *const libc::c_char,
                b"Hacl_Bignum4096_32.c\0" as *const u8 as *const libc::c_char,
                505 as libc::c_int,
            );
            exit(253 as libc::c_int);
        }
        let vla = bLen as usize;
        let mut b2: Vec::<uint32_t> = ::std::vec::from_elem(0, vla);
        memset(
            b2.as_mut_ptr() as *mut libc::c_void,
            0 as libc::c_uint as libc::c_int,
            (bLen as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
        );
        let mut i0: uint32_t = bBits.wrapping_div(32 as libc::c_uint);
        let mut j: uint32_t = bBits.wrapping_rem(32 as libc::c_uint);
        *b2
            .as_mut_ptr()
            .offset(
                i0 as isize,
            ) = *b2.as_mut_ptr().offset(i0 as isize) | (1 as libc::c_uint) << j;
        let mut acc: uint32_t = 0 as libc::c_uint;
        let mut i_0: uint32_t = 0 as libc::c_uint;
        while i_0 < bLen {
            let mut beq_0: uint32_t = FStar_UInt32_eq_mask(
                *b.offset(i_0 as isize),
                *b2.as_mut_ptr().offset(i_0 as isize),
            );
            let mut blt_0: uint32_t = !FStar_UInt32_gte_mask(
                *b.offset(i_0 as isize),
                *b2.as_mut_ptr().offset(i_0 as isize),
            );
            acc = beq_0 & acc | !beq_0 & blt_0;
            i_0 = i_0.wrapping_add(1);
            i_0;
        }
        let mut res: uint32_t = acc;
        m1 = res;
    } else {
        m1 = 0xffffffff as libc::c_uint;
    }
    let mut acc_0: uint32_t = 0 as libc::c_uint;
    let mut i_1: uint32_t = 0 as libc::c_uint;
    while i_1 < 128 as libc::c_uint {
        let mut beq_1: uint32_t = FStar_UInt32_eq_mask(
            *a.offset(i_1 as isize),
            *n.offset(i_1 as isize),
        );
        let mut blt_1: uint32_t = !FStar_UInt32_gte_mask(
            *a.offset(i_1 as isize),
            *n.offset(i_1 as isize),
        );
        acc_0 = beq_1 & acc_0 | !beq_1 & blt_1;
        i_1 = i_1.wrapping_add(1);
        i_1;
    }
    let mut m2: uint32_t = acc_0;
    let mut m: uint32_t = m1 & m2;
    return m00 & m;
}
#[inline]
unsafe extern "C" fn exp_vartime_precomp(
    mut n: *mut uint32_t,
    mut mu: uint32_t,
    mut r2: *mut uint32_t,
    mut a: *mut uint32_t,
    mut bBits: uint32_t,
    mut b: *mut uint32_t,
    mut res: *mut uint32_t,
) {
    if bBits < 200 as libc::c_uint {
        let mut aM: [uint32_t; 128] = [
            0 as libc::c_uint,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
        ];
        to(n, mu, r2, a, aM.as_mut_ptr());
        let mut resM: [uint32_t; 128] = [
            0 as libc::c_uint,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
        ];
        let mut ctx: [uint32_t; 256] = [
            0 as libc::c_uint,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
        ];
        memcpy(
            ctx.as_mut_ptr() as *mut libc::c_void,
            n as *const libc::c_void,
            (128 as libc::c_uint as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
        );
        memcpy(
            ctx.as_mut_ptr().offset(128 as libc::c_uint as isize) as *mut libc::c_void,
            r2 as *const libc::c_void,
            (128 as libc::c_uint as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
        );
        let mut ctx_n0: *mut uint32_t = ctx.as_mut_ptr();
        let mut ctx_r2: *mut uint32_t = ctx
            .as_mut_ptr()
            .offset(128 as libc::c_uint as isize);
        from(ctx_n0, mu, ctx_r2, resM.as_mut_ptr());
        let mut i: uint32_t = 0 as libc::c_uint;
        while i < bBits {
            let mut i1: uint32_t = i.wrapping_div(32 as libc::c_uint);
            let mut j: uint32_t = i.wrapping_rem(32 as libc::c_uint);
            let mut tmp: uint32_t = *b.offset(i1 as isize);
            let mut bit: uint32_t = tmp >> j & 1 as libc::c_uint;
            if !(bit == 0 as libc::c_uint) {
                let mut aM_copy: [uint32_t; 128] = [
                    0 as libc::c_uint,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                ];
                memcpy(
                    aM_copy.as_mut_ptr() as *mut libc::c_void,
                    resM.as_mut_ptr() as *const libc::c_void,
                    (128 as libc::c_uint as libc::c_ulong)
                        .wrapping_mul(
                            ::core::mem::size_of::<uint32_t>() as libc::c_ulong,
                        ),
                );
                let mut ctx_n: *mut uint32_t = ctx.as_mut_ptr();
                amont_mul(
                    ctx_n,
                    mu,
                    aM_copy.as_mut_ptr(),
                    aM.as_mut_ptr(),
                    resM.as_mut_ptr(),
                );
            }
            let mut aM_copy_0: [uint32_t; 128] = [
                0 as libc::c_uint,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
            ];
            memcpy(
                aM_copy_0.as_mut_ptr() as *mut libc::c_void,
                aM.as_mut_ptr() as *const libc::c_void,
                (128 as libc::c_uint as libc::c_ulong)
                    .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
            );
            let mut ctx_n_0: *mut uint32_t = ctx.as_mut_ptr();
            amont_sqr(ctx_n_0, mu, aM_copy_0.as_mut_ptr(), aM.as_mut_ptr());
            i = i.wrapping_add(1);
            i;
        }
        from(n, mu, resM.as_mut_ptr(), res);
        return;
    }
    let mut aM_0: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    to(n, mu, r2, a, aM_0.as_mut_ptr());
    let mut resM_0: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    let mut bLen: uint32_t = 0;
    if bBits == 0 as libc::c_uint {
        bLen = 1 as libc::c_uint;
    } else {
        bLen = bBits
            .wrapping_sub(1 as libc::c_uint)
            .wrapping_div(32 as libc::c_uint)
            .wrapping_add(1 as libc::c_uint);
    }
    let mut ctx_0: [uint32_t; 256] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    memcpy(
        ctx_0.as_mut_ptr() as *mut libc::c_void,
        n as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    memcpy(
        ctx_0.as_mut_ptr().offset(128 as libc::c_uint as isize) as *mut libc::c_void,
        r2 as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut table: [uint32_t; 2048] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    let mut tmp_0: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    let mut t0: *mut uint32_t = table.as_mut_ptr();
    let mut t1: *mut uint32_t = table.as_mut_ptr().offset(128 as libc::c_uint as isize);
    let mut ctx_n0_0: *mut uint32_t = ctx_0.as_mut_ptr();
    let mut ctx_r20: *mut uint32_t = ctx_0
        .as_mut_ptr()
        .offset(128 as libc::c_uint as isize);
    from(ctx_n0_0, mu, ctx_r20, t0);
    memcpy(
        t1 as *mut libc::c_void,
        aM_0.as_mut_ptr() as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut i_0: uint32_t = 0 as libc::c_uint;
    let mut t11: *mut uint32_t = table
        .as_mut_ptr()
        .offset(
            i_0.wrapping_add(1 as libc::c_uint).wrapping_mul(128 as libc::c_uint)
                as isize,
        );
    let mut aM_copy0: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    memcpy(
        aM_copy0.as_mut_ptr() as *mut libc::c_void,
        t11 as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut ctx_n1: *mut uint32_t = ctx_0.as_mut_ptr();
    amont_sqr(ctx_n1, mu, aM_copy0.as_mut_ptr(), tmp_0.as_mut_ptr());
    memcpy(
        table
            .as_mut_ptr()
            .offset(
                (2 as libc::c_uint)
                    .wrapping_mul(i_0)
                    .wrapping_add(2 as libc::c_uint)
                    .wrapping_mul(128 as libc::c_uint) as isize,
            ) as *mut libc::c_void,
        tmp_0.as_mut_ptr() as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut t2: *mut uint32_t = table
        .as_mut_ptr()
        .offset(
            (2 as libc::c_uint)
                .wrapping_mul(i_0)
                .wrapping_add(2 as libc::c_uint)
                .wrapping_mul(128 as libc::c_uint) as isize,
        );
    let mut aM_copy_1: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    memcpy(
        aM_copy_1.as_mut_ptr() as *mut libc::c_void,
        aM_0.as_mut_ptr() as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut ctx_n_1: *mut uint32_t = ctx_0.as_mut_ptr();
    amont_mul(ctx_n_1, mu, aM_copy_1.as_mut_ptr(), t2, tmp_0.as_mut_ptr());
    memcpy(
        table
            .as_mut_ptr()
            .offset(
                (2 as libc::c_uint)
                    .wrapping_mul(i_0)
                    .wrapping_add(3 as libc::c_uint)
                    .wrapping_mul(128 as libc::c_uint) as isize,
            ) as *mut libc::c_void,
        tmp_0.as_mut_ptr() as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    i_0 = (i_0 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t as uint32_t;
    let mut t11_0: *mut uint32_t = table
        .as_mut_ptr()
        .offset(
            i_0.wrapping_add(1 as libc::c_uint).wrapping_mul(128 as libc::c_uint)
                as isize,
        );
    let mut aM_copy0_0: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    memcpy(
        aM_copy0_0.as_mut_ptr() as *mut libc::c_void,
        t11_0 as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut ctx_n1_0: *mut uint32_t = ctx_0.as_mut_ptr();
    amont_sqr(ctx_n1_0, mu, aM_copy0_0.as_mut_ptr(), tmp_0.as_mut_ptr());
    memcpy(
        table
            .as_mut_ptr()
            .offset(
                (2 as libc::c_uint)
                    .wrapping_mul(i_0)
                    .wrapping_add(2 as libc::c_uint)
                    .wrapping_mul(128 as libc::c_uint) as isize,
            ) as *mut libc::c_void,
        tmp_0.as_mut_ptr() as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut t2_0: *mut uint32_t = table
        .as_mut_ptr()
        .offset(
            (2 as libc::c_uint)
                .wrapping_mul(i_0)
                .wrapping_add(2 as libc::c_uint)
                .wrapping_mul(128 as libc::c_uint) as isize,
        );
    let mut aM_copy_2: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    memcpy(
        aM_copy_2.as_mut_ptr() as *mut libc::c_void,
        aM_0.as_mut_ptr() as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut ctx_n_2: *mut uint32_t = ctx_0.as_mut_ptr();
    amont_mul(ctx_n_2, mu, aM_copy_2.as_mut_ptr(), t2_0, tmp_0.as_mut_ptr());
    memcpy(
        table
            .as_mut_ptr()
            .offset(
                (2 as libc::c_uint)
                    .wrapping_mul(i_0)
                    .wrapping_add(3 as libc::c_uint)
                    .wrapping_mul(128 as libc::c_uint) as isize,
            ) as *mut libc::c_void,
        tmp_0.as_mut_ptr() as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    i_0 = (i_0 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t as uint32_t;
    let mut t11_1: *mut uint32_t = table
        .as_mut_ptr()
        .offset(
            i_0.wrapping_add(1 as libc::c_uint).wrapping_mul(128 as libc::c_uint)
                as isize,
        );
    let mut aM_copy0_1: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    memcpy(
        aM_copy0_1.as_mut_ptr() as *mut libc::c_void,
        t11_1 as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut ctx_n1_1: *mut uint32_t = ctx_0.as_mut_ptr();
    amont_sqr(ctx_n1_1, mu, aM_copy0_1.as_mut_ptr(), tmp_0.as_mut_ptr());
    memcpy(
        table
            .as_mut_ptr()
            .offset(
                (2 as libc::c_uint)
                    .wrapping_mul(i_0)
                    .wrapping_add(2 as libc::c_uint)
                    .wrapping_mul(128 as libc::c_uint) as isize,
            ) as *mut libc::c_void,
        tmp_0.as_mut_ptr() as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut t2_1: *mut uint32_t = table
        .as_mut_ptr()
        .offset(
            (2 as libc::c_uint)
                .wrapping_mul(i_0)
                .wrapping_add(2 as libc::c_uint)
                .wrapping_mul(128 as libc::c_uint) as isize,
        );
    let mut aM_copy_3: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    memcpy(
        aM_copy_3.as_mut_ptr() as *mut libc::c_void,
        aM_0.as_mut_ptr() as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut ctx_n_3: *mut uint32_t = ctx_0.as_mut_ptr();
    amont_mul(ctx_n_3, mu, aM_copy_3.as_mut_ptr(), t2_1, tmp_0.as_mut_ptr());
    memcpy(
        table
            .as_mut_ptr()
            .offset(
                (2 as libc::c_uint)
                    .wrapping_mul(i_0)
                    .wrapping_add(3 as libc::c_uint)
                    .wrapping_mul(128 as libc::c_uint) as isize,
            ) as *mut libc::c_void,
        tmp_0.as_mut_ptr() as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    i_0 = (i_0 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t as uint32_t;
    let mut t11_2: *mut uint32_t = table
        .as_mut_ptr()
        .offset(
            i_0.wrapping_add(1 as libc::c_uint).wrapping_mul(128 as libc::c_uint)
                as isize,
        );
    let mut aM_copy0_2: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    memcpy(
        aM_copy0_2.as_mut_ptr() as *mut libc::c_void,
        t11_2 as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut ctx_n1_2: *mut uint32_t = ctx_0.as_mut_ptr();
    amont_sqr(ctx_n1_2, mu, aM_copy0_2.as_mut_ptr(), tmp_0.as_mut_ptr());
    memcpy(
        table
            .as_mut_ptr()
            .offset(
                (2 as libc::c_uint)
                    .wrapping_mul(i_0)
                    .wrapping_add(2 as libc::c_uint)
                    .wrapping_mul(128 as libc::c_uint) as isize,
            ) as *mut libc::c_void,
        tmp_0.as_mut_ptr() as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut t2_2: *mut uint32_t = table
        .as_mut_ptr()
        .offset(
            (2 as libc::c_uint)
                .wrapping_mul(i_0)
                .wrapping_add(2 as libc::c_uint)
                .wrapping_mul(128 as libc::c_uint) as isize,
        );
    let mut aM_copy_4: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    memcpy(
        aM_copy_4.as_mut_ptr() as *mut libc::c_void,
        aM_0.as_mut_ptr() as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut ctx_n_4: *mut uint32_t = ctx_0.as_mut_ptr();
    amont_mul(ctx_n_4, mu, aM_copy_4.as_mut_ptr(), t2_2, tmp_0.as_mut_ptr());
    memcpy(
        table
            .as_mut_ptr()
            .offset(
                (2 as libc::c_uint)
                    .wrapping_mul(i_0)
                    .wrapping_add(3 as libc::c_uint)
                    .wrapping_mul(128 as libc::c_uint) as isize,
            ) as *mut libc::c_void,
        tmp_0.as_mut_ptr() as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    i_0 = (i_0 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t as uint32_t;
    let mut t11_3: *mut uint32_t = table
        .as_mut_ptr()
        .offset(
            i_0.wrapping_add(1 as libc::c_uint).wrapping_mul(128 as libc::c_uint)
                as isize,
        );
    let mut aM_copy0_3: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    memcpy(
        aM_copy0_3.as_mut_ptr() as *mut libc::c_void,
        t11_3 as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut ctx_n1_3: *mut uint32_t = ctx_0.as_mut_ptr();
    amont_sqr(ctx_n1_3, mu, aM_copy0_3.as_mut_ptr(), tmp_0.as_mut_ptr());
    memcpy(
        table
            .as_mut_ptr()
            .offset(
                (2 as libc::c_uint)
                    .wrapping_mul(i_0)
                    .wrapping_add(2 as libc::c_uint)
                    .wrapping_mul(128 as libc::c_uint) as isize,
            ) as *mut libc::c_void,
        tmp_0.as_mut_ptr() as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut t2_3: *mut uint32_t = table
        .as_mut_ptr()
        .offset(
            (2 as libc::c_uint)
                .wrapping_mul(i_0)
                .wrapping_add(2 as libc::c_uint)
                .wrapping_mul(128 as libc::c_uint) as isize,
        );
    let mut aM_copy_5: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    memcpy(
        aM_copy_5.as_mut_ptr() as *mut libc::c_void,
        aM_0.as_mut_ptr() as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut ctx_n_5: *mut uint32_t = ctx_0.as_mut_ptr();
    amont_mul(ctx_n_5, mu, aM_copy_5.as_mut_ptr(), t2_3, tmp_0.as_mut_ptr());
    memcpy(
        table
            .as_mut_ptr()
            .offset(
                (2 as libc::c_uint)
                    .wrapping_mul(i_0)
                    .wrapping_add(3 as libc::c_uint)
                    .wrapping_mul(128 as libc::c_uint) as isize,
            ) as *mut libc::c_void,
        tmp_0.as_mut_ptr() as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    i_0 = (i_0 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t as uint32_t;
    let mut t11_4: *mut uint32_t = table
        .as_mut_ptr()
        .offset(
            i_0.wrapping_add(1 as libc::c_uint).wrapping_mul(128 as libc::c_uint)
                as isize,
        );
    let mut aM_copy0_4: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    memcpy(
        aM_copy0_4.as_mut_ptr() as *mut libc::c_void,
        t11_4 as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut ctx_n1_4: *mut uint32_t = ctx_0.as_mut_ptr();
    amont_sqr(ctx_n1_4, mu, aM_copy0_4.as_mut_ptr(), tmp_0.as_mut_ptr());
    memcpy(
        table
            .as_mut_ptr()
            .offset(
                (2 as libc::c_uint)
                    .wrapping_mul(i_0)
                    .wrapping_add(2 as libc::c_uint)
                    .wrapping_mul(128 as libc::c_uint) as isize,
            ) as *mut libc::c_void,
        tmp_0.as_mut_ptr() as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut t2_4: *mut uint32_t = table
        .as_mut_ptr()
        .offset(
            (2 as libc::c_uint)
                .wrapping_mul(i_0)
                .wrapping_add(2 as libc::c_uint)
                .wrapping_mul(128 as libc::c_uint) as isize,
        );
    let mut aM_copy_6: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    memcpy(
        aM_copy_6.as_mut_ptr() as *mut libc::c_void,
        aM_0.as_mut_ptr() as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut ctx_n_6: *mut uint32_t = ctx_0.as_mut_ptr();
    amont_mul(ctx_n_6, mu, aM_copy_6.as_mut_ptr(), t2_4, tmp_0.as_mut_ptr());
    memcpy(
        table
            .as_mut_ptr()
            .offset(
                (2 as libc::c_uint)
                    .wrapping_mul(i_0)
                    .wrapping_add(3 as libc::c_uint)
                    .wrapping_mul(128 as libc::c_uint) as isize,
            ) as *mut libc::c_void,
        tmp_0.as_mut_ptr() as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    i_0 = (i_0 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t as uint32_t;
    let mut t11_5: *mut uint32_t = table
        .as_mut_ptr()
        .offset(
            i_0.wrapping_add(1 as libc::c_uint).wrapping_mul(128 as libc::c_uint)
                as isize,
        );
    let mut aM_copy0_5: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    memcpy(
        aM_copy0_5.as_mut_ptr() as *mut libc::c_void,
        t11_5 as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut ctx_n1_5: *mut uint32_t = ctx_0.as_mut_ptr();
    amont_sqr(ctx_n1_5, mu, aM_copy0_5.as_mut_ptr(), tmp_0.as_mut_ptr());
    memcpy(
        table
            .as_mut_ptr()
            .offset(
                (2 as libc::c_uint)
                    .wrapping_mul(i_0)
                    .wrapping_add(2 as libc::c_uint)
                    .wrapping_mul(128 as libc::c_uint) as isize,
            ) as *mut libc::c_void,
        tmp_0.as_mut_ptr() as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut t2_5: *mut uint32_t = table
        .as_mut_ptr()
        .offset(
            (2 as libc::c_uint)
                .wrapping_mul(i_0)
                .wrapping_add(2 as libc::c_uint)
                .wrapping_mul(128 as libc::c_uint) as isize,
        );
    let mut aM_copy_7: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    memcpy(
        aM_copy_7.as_mut_ptr() as *mut libc::c_void,
        aM_0.as_mut_ptr() as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut ctx_n_7: *mut uint32_t = ctx_0.as_mut_ptr();
    amont_mul(ctx_n_7, mu, aM_copy_7.as_mut_ptr(), t2_5, tmp_0.as_mut_ptr());
    memcpy(
        table
            .as_mut_ptr()
            .offset(
                (2 as libc::c_uint)
                    .wrapping_mul(i_0)
                    .wrapping_add(3 as libc::c_uint)
                    .wrapping_mul(128 as libc::c_uint) as isize,
            ) as *mut libc::c_void,
        tmp_0.as_mut_ptr() as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    i_0 = (i_0 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t as uint32_t;
    if bBits.wrapping_rem(4 as libc::c_uint) != 0 as libc::c_uint {
        let mut i_1: uint32_t = bBits
            .wrapping_div(4 as libc::c_uint)
            .wrapping_mul(4 as libc::c_uint);
        let mut bits_c: uint32_t = Hacl_Bignum_Lib_bn_get_bits_u32(
            bLen,
            b,
            i_1,
            4 as libc::c_uint,
        );
        let mut bits_l32: uint32_t = bits_c;
        let mut a_bits_l: *const uint32_t = table
            .as_mut_ptr()
            .offset(bits_l32.wrapping_mul(128 as libc::c_uint) as isize);
        memcpy(
            resM_0.as_mut_ptr() as *mut libc::c_void,
            a_bits_l as *mut uint32_t as *const libc::c_void,
            (128 as libc::c_uint as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
        );
    } else {
        let mut ctx_n_8: *mut uint32_t = ctx_0.as_mut_ptr();
        let mut ctx_r2_0: *mut uint32_t = ctx_0
            .as_mut_ptr()
            .offset(128 as libc::c_uint as isize);
        from(ctx_n_8, mu, ctx_r2_0, resM_0.as_mut_ptr());
    }
    let mut tmp0: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    let mut i_2: uint32_t = 0 as libc::c_uint;
    while i_2 < bBits.wrapping_div(4 as libc::c_uint) {
        let mut i0: uint32_t = 0 as libc::c_uint;
        let mut aM_copy_8: [uint32_t; 128] = [
            0 as libc::c_uint,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
        ];
        memcpy(
            aM_copy_8.as_mut_ptr() as *mut libc::c_void,
            resM_0.as_mut_ptr() as *const libc::c_void,
            (128 as libc::c_uint as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
        );
        let mut ctx_n_9: *mut uint32_t = ctx_0.as_mut_ptr();
        amont_sqr(ctx_n_9, mu, aM_copy_8.as_mut_ptr(), resM_0.as_mut_ptr());
        i0 = (i0 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t
            as uint32_t;
        let mut aM_copy_9: [uint32_t; 128] = [
            0 as libc::c_uint,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
        ];
        memcpy(
            aM_copy_9.as_mut_ptr() as *mut libc::c_void,
            resM_0.as_mut_ptr() as *const libc::c_void,
            (128 as libc::c_uint as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
        );
        let mut ctx_n_10: *mut uint32_t = ctx_0.as_mut_ptr();
        amont_sqr(ctx_n_10, mu, aM_copy_9.as_mut_ptr(), resM_0.as_mut_ptr());
        i0 = (i0 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t
            as uint32_t;
        let mut aM_copy_10: [uint32_t; 128] = [
            0 as libc::c_uint,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
        ];
        memcpy(
            aM_copy_10.as_mut_ptr() as *mut libc::c_void,
            resM_0.as_mut_ptr() as *const libc::c_void,
            (128 as libc::c_uint as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
        );
        let mut ctx_n_11: *mut uint32_t = ctx_0.as_mut_ptr();
        amont_sqr(ctx_n_11, mu, aM_copy_10.as_mut_ptr(), resM_0.as_mut_ptr());
        i0 = (i0 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t
            as uint32_t;
        let mut aM_copy_11: [uint32_t; 128] = [
            0 as libc::c_uint,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
        ];
        memcpy(
            aM_copy_11.as_mut_ptr() as *mut libc::c_void,
            resM_0.as_mut_ptr() as *const libc::c_void,
            (128 as libc::c_uint as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
        );
        let mut ctx_n_12: *mut uint32_t = ctx_0.as_mut_ptr();
        amont_sqr(ctx_n_12, mu, aM_copy_11.as_mut_ptr(), resM_0.as_mut_ptr());
        i0 = (i0 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t
            as uint32_t;
        let mut k: uint32_t = bBits
            .wrapping_sub(bBits.wrapping_rem(4 as libc::c_uint))
            .wrapping_sub((4 as libc::c_uint).wrapping_mul(i_2))
            .wrapping_sub(4 as libc::c_uint);
        let mut bits_l: uint32_t = Hacl_Bignum_Lib_bn_get_bits_u32(
            bLen,
            b,
            k,
            4 as libc::c_uint,
        );
        let mut bits_l32_0: uint32_t = bits_l;
        let mut a_bits_l_0: *const uint32_t = table
            .as_mut_ptr()
            .offset(bits_l32_0.wrapping_mul(128 as libc::c_uint) as isize);
        memcpy(
            tmp0.as_mut_ptr() as *mut libc::c_void,
            a_bits_l_0 as *mut uint32_t as *const libc::c_void,
            (128 as libc::c_uint as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
        );
        let mut aM_copy_12: [uint32_t; 128] = [
            0 as libc::c_uint,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
        ];
        memcpy(
            aM_copy_12.as_mut_ptr() as *mut libc::c_void,
            resM_0.as_mut_ptr() as *const libc::c_void,
            (128 as libc::c_uint as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
        );
        let mut ctx_n_13: *mut uint32_t = ctx_0.as_mut_ptr();
        amont_mul(
            ctx_n_13,
            mu,
            aM_copy_12.as_mut_ptr(),
            tmp0.as_mut_ptr(),
            resM_0.as_mut_ptr(),
        );
        i_2 = i_2.wrapping_add(1);
        i_2;
    }
    from(n, mu, resM_0.as_mut_ptr(), res);
}
#[inline]
unsafe extern "C" fn exp_consttime_precomp(
    mut n: *mut uint32_t,
    mut mu: uint32_t,
    mut r2: *mut uint32_t,
    mut a: *mut uint32_t,
    mut bBits: uint32_t,
    mut b: *mut uint32_t,
    mut res: *mut uint32_t,
) {
    if bBits < 200 as libc::c_uint {
        let mut aM: [uint32_t; 128] = [
            0 as libc::c_uint,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
        ];
        to(n, mu, r2, a, aM.as_mut_ptr());
        let mut resM: [uint32_t; 128] = [
            0 as libc::c_uint,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
        ];
        let mut ctx: [uint32_t; 256] = [
            0 as libc::c_uint,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
        ];
        memcpy(
            ctx.as_mut_ptr() as *mut libc::c_void,
            n as *const libc::c_void,
            (128 as libc::c_uint as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
        );
        memcpy(
            ctx.as_mut_ptr().offset(128 as libc::c_uint as isize) as *mut libc::c_void,
            r2 as *const libc::c_void,
            (128 as libc::c_uint as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
        );
        let mut sw: uint32_t = 0 as libc::c_uint;
        let mut ctx_n0: *mut uint32_t = ctx.as_mut_ptr();
        let mut ctx_r2: *mut uint32_t = ctx
            .as_mut_ptr()
            .offset(128 as libc::c_uint as isize);
        from(ctx_n0, mu, ctx_r2, resM.as_mut_ptr());
        let mut i0: uint32_t = 0 as libc::c_uint;
        while i0 < bBits {
            let mut i1: uint32_t = bBits
                .wrapping_sub(i0)
                .wrapping_sub(1 as libc::c_uint)
                .wrapping_div(32 as libc::c_uint);
            let mut j: uint32_t = bBits
                .wrapping_sub(i0)
                .wrapping_sub(1 as libc::c_uint)
                .wrapping_rem(32 as libc::c_uint);
            let mut tmp: uint32_t = *b.offset(i1 as isize);
            let mut bit: uint32_t = tmp >> j & 1 as libc::c_uint;
            let mut sw1: uint32_t = bit ^ sw;
            let mut i: uint32_t = 0 as libc::c_uint;
            while i < 128 as libc::c_uint {
                let mut dummy: uint32_t = (0 as libc::c_uint).wrapping_sub(sw1)
                    & (resM[i as usize] ^ aM[i as usize]);
                resM[i as usize] = resM[i as usize] ^ dummy;
                aM[i as usize] = aM[i as usize] ^ dummy;
                i = i.wrapping_add(1);
                i;
            }
            let mut aM_copy: [uint32_t; 128] = [
                0 as libc::c_uint,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
            ];
            memcpy(
                aM_copy.as_mut_ptr() as *mut libc::c_void,
                aM.as_mut_ptr() as *const libc::c_void,
                (128 as libc::c_uint as libc::c_ulong)
                    .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
            );
            let mut ctx_n1: *mut uint32_t = ctx.as_mut_ptr();
            amont_mul(
                ctx_n1,
                mu,
                aM_copy.as_mut_ptr(),
                resM.as_mut_ptr(),
                aM.as_mut_ptr(),
            );
            let mut aM_copy0: [uint32_t; 128] = [
                0 as libc::c_uint,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
            ];
            memcpy(
                aM_copy0.as_mut_ptr() as *mut libc::c_void,
                resM.as_mut_ptr() as *const libc::c_void,
                (128 as libc::c_uint as libc::c_ulong)
                    .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
            );
            let mut ctx_n: *mut uint32_t = ctx.as_mut_ptr();
            amont_sqr(ctx_n, mu, aM_copy0.as_mut_ptr(), resM.as_mut_ptr());
            sw = bit;
            i0 = i0.wrapping_add(1);
            i0;
        }
        let mut sw0: uint32_t = sw;
        let mut i_0: uint32_t = 0 as libc::c_uint;
        while i_0 < 128 as libc::c_uint {
            let mut dummy_0: uint32_t = (0 as libc::c_uint).wrapping_sub(sw0)
                & (resM[i_0 as usize] ^ aM[i_0 as usize]);
            resM[i_0 as usize] = resM[i_0 as usize] ^ dummy_0;
            aM[i_0 as usize] = aM[i_0 as usize] ^ dummy_0;
            i_0 = i_0.wrapping_add(1);
            i_0;
        }
        from(n, mu, resM.as_mut_ptr(), res);
        return;
    }
    let mut aM_0: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    to(n, mu, r2, a, aM_0.as_mut_ptr());
    let mut resM_0: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    let mut bLen: uint32_t = 0;
    if bBits == 0 as libc::c_uint {
        bLen = 1 as libc::c_uint;
    } else {
        bLen = bBits
            .wrapping_sub(1 as libc::c_uint)
            .wrapping_div(32 as libc::c_uint)
            .wrapping_add(1 as libc::c_uint);
    }
    let mut ctx_0: [uint32_t; 256] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    memcpy(
        ctx_0.as_mut_ptr() as *mut libc::c_void,
        n as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    memcpy(
        ctx_0.as_mut_ptr().offset(128 as libc::c_uint as isize) as *mut libc::c_void,
        r2 as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut table: [uint32_t; 2048] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    let mut tmp_0: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    let mut t0: *mut uint32_t = table.as_mut_ptr();
    let mut t1: *mut uint32_t = table.as_mut_ptr().offset(128 as libc::c_uint as isize);
    let mut ctx_n0_0: *mut uint32_t = ctx_0.as_mut_ptr();
    let mut ctx_r20: *mut uint32_t = ctx_0
        .as_mut_ptr()
        .offset(128 as libc::c_uint as isize);
    from(ctx_n0_0, mu, ctx_r20, t0);
    memcpy(
        t1 as *mut libc::c_void,
        aM_0.as_mut_ptr() as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut i_1: uint32_t = 0 as libc::c_uint;
    let mut t11: *mut uint32_t = table
        .as_mut_ptr()
        .offset(
            i_1.wrapping_add(1 as libc::c_uint).wrapping_mul(128 as libc::c_uint)
                as isize,
        );
    let mut aM_copy0_0: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    memcpy(
        aM_copy0_0.as_mut_ptr() as *mut libc::c_void,
        t11 as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut ctx_n1_0: *mut uint32_t = ctx_0.as_mut_ptr();
    amont_sqr(ctx_n1_0, mu, aM_copy0_0.as_mut_ptr(), tmp_0.as_mut_ptr());
    memcpy(
        table
            .as_mut_ptr()
            .offset(
                (2 as libc::c_uint)
                    .wrapping_mul(i_1)
                    .wrapping_add(2 as libc::c_uint)
                    .wrapping_mul(128 as libc::c_uint) as isize,
            ) as *mut libc::c_void,
        tmp_0.as_mut_ptr() as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut t2: *mut uint32_t = table
        .as_mut_ptr()
        .offset(
            (2 as libc::c_uint)
                .wrapping_mul(i_1)
                .wrapping_add(2 as libc::c_uint)
                .wrapping_mul(128 as libc::c_uint) as isize,
        );
    let mut aM_copy_0: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    memcpy(
        aM_copy_0.as_mut_ptr() as *mut libc::c_void,
        aM_0.as_mut_ptr() as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut ctx_n_0: *mut uint32_t = ctx_0.as_mut_ptr();
    amont_mul(ctx_n_0, mu, aM_copy_0.as_mut_ptr(), t2, tmp_0.as_mut_ptr());
    memcpy(
        table
            .as_mut_ptr()
            .offset(
                (2 as libc::c_uint)
                    .wrapping_mul(i_1)
                    .wrapping_add(3 as libc::c_uint)
                    .wrapping_mul(128 as libc::c_uint) as isize,
            ) as *mut libc::c_void,
        tmp_0.as_mut_ptr() as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    i_1 = (i_1 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t as uint32_t;
    let mut t11_0: *mut uint32_t = table
        .as_mut_ptr()
        .offset(
            i_1.wrapping_add(1 as libc::c_uint).wrapping_mul(128 as libc::c_uint)
                as isize,
        );
    let mut aM_copy0_1: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    memcpy(
        aM_copy0_1.as_mut_ptr() as *mut libc::c_void,
        t11_0 as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut ctx_n1_1: *mut uint32_t = ctx_0.as_mut_ptr();
    amont_sqr(ctx_n1_1, mu, aM_copy0_1.as_mut_ptr(), tmp_0.as_mut_ptr());
    memcpy(
        table
            .as_mut_ptr()
            .offset(
                (2 as libc::c_uint)
                    .wrapping_mul(i_1)
                    .wrapping_add(2 as libc::c_uint)
                    .wrapping_mul(128 as libc::c_uint) as isize,
            ) as *mut libc::c_void,
        tmp_0.as_mut_ptr() as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut t2_0: *mut uint32_t = table
        .as_mut_ptr()
        .offset(
            (2 as libc::c_uint)
                .wrapping_mul(i_1)
                .wrapping_add(2 as libc::c_uint)
                .wrapping_mul(128 as libc::c_uint) as isize,
        );
    let mut aM_copy_1: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    memcpy(
        aM_copy_1.as_mut_ptr() as *mut libc::c_void,
        aM_0.as_mut_ptr() as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut ctx_n_1: *mut uint32_t = ctx_0.as_mut_ptr();
    amont_mul(ctx_n_1, mu, aM_copy_1.as_mut_ptr(), t2_0, tmp_0.as_mut_ptr());
    memcpy(
        table
            .as_mut_ptr()
            .offset(
                (2 as libc::c_uint)
                    .wrapping_mul(i_1)
                    .wrapping_add(3 as libc::c_uint)
                    .wrapping_mul(128 as libc::c_uint) as isize,
            ) as *mut libc::c_void,
        tmp_0.as_mut_ptr() as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    i_1 = (i_1 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t as uint32_t;
    let mut t11_1: *mut uint32_t = table
        .as_mut_ptr()
        .offset(
            i_1.wrapping_add(1 as libc::c_uint).wrapping_mul(128 as libc::c_uint)
                as isize,
        );
    let mut aM_copy0_2: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    memcpy(
        aM_copy0_2.as_mut_ptr() as *mut libc::c_void,
        t11_1 as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut ctx_n1_2: *mut uint32_t = ctx_0.as_mut_ptr();
    amont_sqr(ctx_n1_2, mu, aM_copy0_2.as_mut_ptr(), tmp_0.as_mut_ptr());
    memcpy(
        table
            .as_mut_ptr()
            .offset(
                (2 as libc::c_uint)
                    .wrapping_mul(i_1)
                    .wrapping_add(2 as libc::c_uint)
                    .wrapping_mul(128 as libc::c_uint) as isize,
            ) as *mut libc::c_void,
        tmp_0.as_mut_ptr() as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut t2_1: *mut uint32_t = table
        .as_mut_ptr()
        .offset(
            (2 as libc::c_uint)
                .wrapping_mul(i_1)
                .wrapping_add(2 as libc::c_uint)
                .wrapping_mul(128 as libc::c_uint) as isize,
        );
    let mut aM_copy_2: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    memcpy(
        aM_copy_2.as_mut_ptr() as *mut libc::c_void,
        aM_0.as_mut_ptr() as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut ctx_n_2: *mut uint32_t = ctx_0.as_mut_ptr();
    amont_mul(ctx_n_2, mu, aM_copy_2.as_mut_ptr(), t2_1, tmp_0.as_mut_ptr());
    memcpy(
        table
            .as_mut_ptr()
            .offset(
                (2 as libc::c_uint)
                    .wrapping_mul(i_1)
                    .wrapping_add(3 as libc::c_uint)
                    .wrapping_mul(128 as libc::c_uint) as isize,
            ) as *mut libc::c_void,
        tmp_0.as_mut_ptr() as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    i_1 = (i_1 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t as uint32_t;
    let mut t11_2: *mut uint32_t = table
        .as_mut_ptr()
        .offset(
            i_1.wrapping_add(1 as libc::c_uint).wrapping_mul(128 as libc::c_uint)
                as isize,
        );
    let mut aM_copy0_3: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    memcpy(
        aM_copy0_3.as_mut_ptr() as *mut libc::c_void,
        t11_2 as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut ctx_n1_3: *mut uint32_t = ctx_0.as_mut_ptr();
    amont_sqr(ctx_n1_3, mu, aM_copy0_3.as_mut_ptr(), tmp_0.as_mut_ptr());
    memcpy(
        table
            .as_mut_ptr()
            .offset(
                (2 as libc::c_uint)
                    .wrapping_mul(i_1)
                    .wrapping_add(2 as libc::c_uint)
                    .wrapping_mul(128 as libc::c_uint) as isize,
            ) as *mut libc::c_void,
        tmp_0.as_mut_ptr() as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut t2_2: *mut uint32_t = table
        .as_mut_ptr()
        .offset(
            (2 as libc::c_uint)
                .wrapping_mul(i_1)
                .wrapping_add(2 as libc::c_uint)
                .wrapping_mul(128 as libc::c_uint) as isize,
        );
    let mut aM_copy_3: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    memcpy(
        aM_copy_3.as_mut_ptr() as *mut libc::c_void,
        aM_0.as_mut_ptr() as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut ctx_n_3: *mut uint32_t = ctx_0.as_mut_ptr();
    amont_mul(ctx_n_3, mu, aM_copy_3.as_mut_ptr(), t2_2, tmp_0.as_mut_ptr());
    memcpy(
        table
            .as_mut_ptr()
            .offset(
                (2 as libc::c_uint)
                    .wrapping_mul(i_1)
                    .wrapping_add(3 as libc::c_uint)
                    .wrapping_mul(128 as libc::c_uint) as isize,
            ) as *mut libc::c_void,
        tmp_0.as_mut_ptr() as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    i_1 = (i_1 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t as uint32_t;
    let mut t11_3: *mut uint32_t = table
        .as_mut_ptr()
        .offset(
            i_1.wrapping_add(1 as libc::c_uint).wrapping_mul(128 as libc::c_uint)
                as isize,
        );
    let mut aM_copy0_4: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    memcpy(
        aM_copy0_4.as_mut_ptr() as *mut libc::c_void,
        t11_3 as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut ctx_n1_4: *mut uint32_t = ctx_0.as_mut_ptr();
    amont_sqr(ctx_n1_4, mu, aM_copy0_4.as_mut_ptr(), tmp_0.as_mut_ptr());
    memcpy(
        table
            .as_mut_ptr()
            .offset(
                (2 as libc::c_uint)
                    .wrapping_mul(i_1)
                    .wrapping_add(2 as libc::c_uint)
                    .wrapping_mul(128 as libc::c_uint) as isize,
            ) as *mut libc::c_void,
        tmp_0.as_mut_ptr() as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut t2_3: *mut uint32_t = table
        .as_mut_ptr()
        .offset(
            (2 as libc::c_uint)
                .wrapping_mul(i_1)
                .wrapping_add(2 as libc::c_uint)
                .wrapping_mul(128 as libc::c_uint) as isize,
        );
    let mut aM_copy_4: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    memcpy(
        aM_copy_4.as_mut_ptr() as *mut libc::c_void,
        aM_0.as_mut_ptr() as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut ctx_n_4: *mut uint32_t = ctx_0.as_mut_ptr();
    amont_mul(ctx_n_4, mu, aM_copy_4.as_mut_ptr(), t2_3, tmp_0.as_mut_ptr());
    memcpy(
        table
            .as_mut_ptr()
            .offset(
                (2 as libc::c_uint)
                    .wrapping_mul(i_1)
                    .wrapping_add(3 as libc::c_uint)
                    .wrapping_mul(128 as libc::c_uint) as isize,
            ) as *mut libc::c_void,
        tmp_0.as_mut_ptr() as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    i_1 = (i_1 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t as uint32_t;
    let mut t11_4: *mut uint32_t = table
        .as_mut_ptr()
        .offset(
            i_1.wrapping_add(1 as libc::c_uint).wrapping_mul(128 as libc::c_uint)
                as isize,
        );
    let mut aM_copy0_5: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    memcpy(
        aM_copy0_5.as_mut_ptr() as *mut libc::c_void,
        t11_4 as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut ctx_n1_5: *mut uint32_t = ctx_0.as_mut_ptr();
    amont_sqr(ctx_n1_5, mu, aM_copy0_5.as_mut_ptr(), tmp_0.as_mut_ptr());
    memcpy(
        table
            .as_mut_ptr()
            .offset(
                (2 as libc::c_uint)
                    .wrapping_mul(i_1)
                    .wrapping_add(2 as libc::c_uint)
                    .wrapping_mul(128 as libc::c_uint) as isize,
            ) as *mut libc::c_void,
        tmp_0.as_mut_ptr() as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut t2_4: *mut uint32_t = table
        .as_mut_ptr()
        .offset(
            (2 as libc::c_uint)
                .wrapping_mul(i_1)
                .wrapping_add(2 as libc::c_uint)
                .wrapping_mul(128 as libc::c_uint) as isize,
        );
    let mut aM_copy_5: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    memcpy(
        aM_copy_5.as_mut_ptr() as *mut libc::c_void,
        aM_0.as_mut_ptr() as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut ctx_n_5: *mut uint32_t = ctx_0.as_mut_ptr();
    amont_mul(ctx_n_5, mu, aM_copy_5.as_mut_ptr(), t2_4, tmp_0.as_mut_ptr());
    memcpy(
        table
            .as_mut_ptr()
            .offset(
                (2 as libc::c_uint)
                    .wrapping_mul(i_1)
                    .wrapping_add(3 as libc::c_uint)
                    .wrapping_mul(128 as libc::c_uint) as isize,
            ) as *mut libc::c_void,
        tmp_0.as_mut_ptr() as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    i_1 = (i_1 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t as uint32_t;
    let mut t11_5: *mut uint32_t = table
        .as_mut_ptr()
        .offset(
            i_1.wrapping_add(1 as libc::c_uint).wrapping_mul(128 as libc::c_uint)
                as isize,
        );
    let mut aM_copy0_6: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    memcpy(
        aM_copy0_6.as_mut_ptr() as *mut libc::c_void,
        t11_5 as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut ctx_n1_6: *mut uint32_t = ctx_0.as_mut_ptr();
    amont_sqr(ctx_n1_6, mu, aM_copy0_6.as_mut_ptr(), tmp_0.as_mut_ptr());
    memcpy(
        table
            .as_mut_ptr()
            .offset(
                (2 as libc::c_uint)
                    .wrapping_mul(i_1)
                    .wrapping_add(2 as libc::c_uint)
                    .wrapping_mul(128 as libc::c_uint) as isize,
            ) as *mut libc::c_void,
        tmp_0.as_mut_ptr() as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut t2_5: *mut uint32_t = table
        .as_mut_ptr()
        .offset(
            (2 as libc::c_uint)
                .wrapping_mul(i_1)
                .wrapping_add(2 as libc::c_uint)
                .wrapping_mul(128 as libc::c_uint) as isize,
        );
    let mut aM_copy_6: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    memcpy(
        aM_copy_6.as_mut_ptr() as *mut libc::c_void,
        aM_0.as_mut_ptr() as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut ctx_n_6: *mut uint32_t = ctx_0.as_mut_ptr();
    amont_mul(ctx_n_6, mu, aM_copy_6.as_mut_ptr(), t2_5, tmp_0.as_mut_ptr());
    memcpy(
        table
            .as_mut_ptr()
            .offset(
                (2 as libc::c_uint)
                    .wrapping_mul(i_1)
                    .wrapping_add(3 as libc::c_uint)
                    .wrapping_mul(128 as libc::c_uint) as isize,
            ) as *mut libc::c_void,
        tmp_0.as_mut_ptr() as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    i_1 = (i_1 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t as uint32_t;
    if bBits.wrapping_rem(4 as libc::c_uint) != 0 as libc::c_uint {
        let mut i0_0: uint32_t = bBits
            .wrapping_div(4 as libc::c_uint)
            .wrapping_mul(4 as libc::c_uint);
        let mut bits_c: uint32_t = Hacl_Bignum_Lib_bn_get_bits_u32(
            bLen,
            b,
            i0_0,
            4 as libc::c_uint,
        );
        memcpy(
            resM_0.as_mut_ptr() as *mut libc::c_void,
            table.as_mut_ptr() as *const libc::c_void,
            (128 as libc::c_uint as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
        );
        let mut i1_0: uint32_t = 0 as libc::c_uint;
        let mut c: uint32_t = FStar_UInt32_eq_mask(
            bits_c,
            i1_0.wrapping_add(1 as libc::c_uint),
        );
        let mut res_j: *const uint32_t = table
            .as_mut_ptr()
            .offset(
                i1_0.wrapping_add(1 as libc::c_uint).wrapping_mul(128 as libc::c_uint)
                    as isize,
            );
        let mut i_2: uint32_t = 0 as libc::c_uint;
        while i_2 < 128 as libc::c_uint {
            let mut x: uint32_t = c & *res_j.offset(i_2 as isize)
                | !c & resM_0[i_2 as usize];
            let mut os: *mut uint32_t = resM_0.as_mut_ptr();
            *os.offset(i_2 as isize) = x;
            i_2 = i_2.wrapping_add(1);
            i_2;
        }
        i1_0 = (i1_0 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t
            as uint32_t;
        let mut c_0: uint32_t = FStar_UInt32_eq_mask(
            bits_c,
            i1_0.wrapping_add(1 as libc::c_uint),
        );
        let mut res_j_0: *const uint32_t = table
            .as_mut_ptr()
            .offset(
                i1_0.wrapping_add(1 as libc::c_uint).wrapping_mul(128 as libc::c_uint)
                    as isize,
            );
        let mut i_3: uint32_t = 0 as libc::c_uint;
        while i_3 < 128 as libc::c_uint {
            let mut x_0: uint32_t = c_0 & *res_j_0.offset(i_3 as isize)
                | !c_0 & resM_0[i_3 as usize];
            let mut os_0: *mut uint32_t = resM_0.as_mut_ptr();
            *os_0.offset(i_3 as isize) = x_0;
            i_3 = i_3.wrapping_add(1);
            i_3;
        }
        i1_0 = (i1_0 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t
            as uint32_t;
        let mut c_1: uint32_t = FStar_UInt32_eq_mask(
            bits_c,
            i1_0.wrapping_add(1 as libc::c_uint),
        );
        let mut res_j_1: *const uint32_t = table
            .as_mut_ptr()
            .offset(
                i1_0.wrapping_add(1 as libc::c_uint).wrapping_mul(128 as libc::c_uint)
                    as isize,
            );
        let mut i_4: uint32_t = 0 as libc::c_uint;
        while i_4 < 128 as libc::c_uint {
            let mut x_1: uint32_t = c_1 & *res_j_1.offset(i_4 as isize)
                | !c_1 & resM_0[i_4 as usize];
            let mut os_1: *mut uint32_t = resM_0.as_mut_ptr();
            *os_1.offset(i_4 as isize) = x_1;
            i_4 = i_4.wrapping_add(1);
            i_4;
        }
        i1_0 = (i1_0 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t
            as uint32_t;
        let mut c_2: uint32_t = FStar_UInt32_eq_mask(
            bits_c,
            i1_0.wrapping_add(1 as libc::c_uint),
        );
        let mut res_j_2: *const uint32_t = table
            .as_mut_ptr()
            .offset(
                i1_0.wrapping_add(1 as libc::c_uint).wrapping_mul(128 as libc::c_uint)
                    as isize,
            );
        let mut i_5: uint32_t = 0 as libc::c_uint;
        while i_5 < 128 as libc::c_uint {
            let mut x_2: uint32_t = c_2 & *res_j_2.offset(i_5 as isize)
                | !c_2 & resM_0[i_5 as usize];
            let mut os_2: *mut uint32_t = resM_0.as_mut_ptr();
            *os_2.offset(i_5 as isize) = x_2;
            i_5 = i_5.wrapping_add(1);
            i_5;
        }
        i1_0 = (i1_0 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t
            as uint32_t;
        let mut c_3: uint32_t = FStar_UInt32_eq_mask(
            bits_c,
            i1_0.wrapping_add(1 as libc::c_uint),
        );
        let mut res_j_3: *const uint32_t = table
            .as_mut_ptr()
            .offset(
                i1_0.wrapping_add(1 as libc::c_uint).wrapping_mul(128 as libc::c_uint)
                    as isize,
            );
        let mut i_6: uint32_t = 0 as libc::c_uint;
        while i_6 < 128 as libc::c_uint {
            let mut x_3: uint32_t = c_3 & *res_j_3.offset(i_6 as isize)
                | !c_3 & resM_0[i_6 as usize];
            let mut os_3: *mut uint32_t = resM_0.as_mut_ptr();
            *os_3.offset(i_6 as isize) = x_3;
            i_6 = i_6.wrapping_add(1);
            i_6;
        }
        i1_0 = (i1_0 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t
            as uint32_t;
        let mut c_4: uint32_t = FStar_UInt32_eq_mask(
            bits_c,
            i1_0.wrapping_add(1 as libc::c_uint),
        );
        let mut res_j_4: *const uint32_t = table
            .as_mut_ptr()
            .offset(
                i1_0.wrapping_add(1 as libc::c_uint).wrapping_mul(128 as libc::c_uint)
                    as isize,
            );
        let mut i_7: uint32_t = 0 as libc::c_uint;
        while i_7 < 128 as libc::c_uint {
            let mut x_4: uint32_t = c_4 & *res_j_4.offset(i_7 as isize)
                | !c_4 & resM_0[i_7 as usize];
            let mut os_4: *mut uint32_t = resM_0.as_mut_ptr();
            *os_4.offset(i_7 as isize) = x_4;
            i_7 = i_7.wrapping_add(1);
            i_7;
        }
        i1_0 = (i1_0 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t
            as uint32_t;
        let mut c_5: uint32_t = FStar_UInt32_eq_mask(
            bits_c,
            i1_0.wrapping_add(1 as libc::c_uint),
        );
        let mut res_j_5: *const uint32_t = table
            .as_mut_ptr()
            .offset(
                i1_0.wrapping_add(1 as libc::c_uint).wrapping_mul(128 as libc::c_uint)
                    as isize,
            );
        let mut i_8: uint32_t = 0 as libc::c_uint;
        while i_8 < 128 as libc::c_uint {
            let mut x_5: uint32_t = c_5 & *res_j_5.offset(i_8 as isize)
                | !c_5 & resM_0[i_8 as usize];
            let mut os_5: *mut uint32_t = resM_0.as_mut_ptr();
            *os_5.offset(i_8 as isize) = x_5;
            i_8 = i_8.wrapping_add(1);
            i_8;
        }
        i1_0 = (i1_0 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t
            as uint32_t;
        let mut c_6: uint32_t = FStar_UInt32_eq_mask(
            bits_c,
            i1_0.wrapping_add(1 as libc::c_uint),
        );
        let mut res_j_6: *const uint32_t = table
            .as_mut_ptr()
            .offset(
                i1_0.wrapping_add(1 as libc::c_uint).wrapping_mul(128 as libc::c_uint)
                    as isize,
            );
        let mut i_9: uint32_t = 0 as libc::c_uint;
        while i_9 < 128 as libc::c_uint {
            let mut x_6: uint32_t = c_6 & *res_j_6.offset(i_9 as isize)
                | !c_6 & resM_0[i_9 as usize];
            let mut os_6: *mut uint32_t = resM_0.as_mut_ptr();
            *os_6.offset(i_9 as isize) = x_6;
            i_9 = i_9.wrapping_add(1);
            i_9;
        }
        i1_0 = (i1_0 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t
            as uint32_t;
        let mut c_7: uint32_t = FStar_UInt32_eq_mask(
            bits_c,
            i1_0.wrapping_add(1 as libc::c_uint),
        );
        let mut res_j_7: *const uint32_t = table
            .as_mut_ptr()
            .offset(
                i1_0.wrapping_add(1 as libc::c_uint).wrapping_mul(128 as libc::c_uint)
                    as isize,
            );
        let mut i_10: uint32_t = 0 as libc::c_uint;
        while i_10 < 128 as libc::c_uint {
            let mut x_7: uint32_t = c_7 & *res_j_7.offset(i_10 as isize)
                | !c_7 & resM_0[i_10 as usize];
            let mut os_7: *mut uint32_t = resM_0.as_mut_ptr();
            *os_7.offset(i_10 as isize) = x_7;
            i_10 = i_10.wrapping_add(1);
            i_10;
        }
        i1_0 = (i1_0 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t
            as uint32_t;
        let mut c_8: uint32_t = FStar_UInt32_eq_mask(
            bits_c,
            i1_0.wrapping_add(1 as libc::c_uint),
        );
        let mut res_j_8: *const uint32_t = table
            .as_mut_ptr()
            .offset(
                i1_0.wrapping_add(1 as libc::c_uint).wrapping_mul(128 as libc::c_uint)
                    as isize,
            );
        let mut i_11: uint32_t = 0 as libc::c_uint;
        while i_11 < 128 as libc::c_uint {
            let mut x_8: uint32_t = c_8 & *res_j_8.offset(i_11 as isize)
                | !c_8 & resM_0[i_11 as usize];
            let mut os_8: *mut uint32_t = resM_0.as_mut_ptr();
            *os_8.offset(i_11 as isize) = x_8;
            i_11 = i_11.wrapping_add(1);
            i_11;
        }
        i1_0 = (i1_0 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t
            as uint32_t;
        let mut c_9: uint32_t = FStar_UInt32_eq_mask(
            bits_c,
            i1_0.wrapping_add(1 as libc::c_uint),
        );
        let mut res_j_9: *const uint32_t = table
            .as_mut_ptr()
            .offset(
                i1_0.wrapping_add(1 as libc::c_uint).wrapping_mul(128 as libc::c_uint)
                    as isize,
            );
        let mut i_12: uint32_t = 0 as libc::c_uint;
        while i_12 < 128 as libc::c_uint {
            let mut x_9: uint32_t = c_9 & *res_j_9.offset(i_12 as isize)
                | !c_9 & resM_0[i_12 as usize];
            let mut os_9: *mut uint32_t = resM_0.as_mut_ptr();
            *os_9.offset(i_12 as isize) = x_9;
            i_12 = i_12.wrapping_add(1);
            i_12;
        }
        i1_0 = (i1_0 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t
            as uint32_t;
        let mut c_10: uint32_t = FStar_UInt32_eq_mask(
            bits_c,
            i1_0.wrapping_add(1 as libc::c_uint),
        );
        let mut res_j_10: *const uint32_t = table
            .as_mut_ptr()
            .offset(
                i1_0.wrapping_add(1 as libc::c_uint).wrapping_mul(128 as libc::c_uint)
                    as isize,
            );
        let mut i_13: uint32_t = 0 as libc::c_uint;
        while i_13 < 128 as libc::c_uint {
            let mut x_10: uint32_t = c_10 & *res_j_10.offset(i_13 as isize)
                | !c_10 & resM_0[i_13 as usize];
            let mut os_10: *mut uint32_t = resM_0.as_mut_ptr();
            *os_10.offset(i_13 as isize) = x_10;
            i_13 = i_13.wrapping_add(1);
            i_13;
        }
        i1_0 = (i1_0 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t
            as uint32_t;
        let mut c_11: uint32_t = FStar_UInt32_eq_mask(
            bits_c,
            i1_0.wrapping_add(1 as libc::c_uint),
        );
        let mut res_j_11: *const uint32_t = table
            .as_mut_ptr()
            .offset(
                i1_0.wrapping_add(1 as libc::c_uint).wrapping_mul(128 as libc::c_uint)
                    as isize,
            );
        let mut i_14: uint32_t = 0 as libc::c_uint;
        while i_14 < 128 as libc::c_uint {
            let mut x_11: uint32_t = c_11 & *res_j_11.offset(i_14 as isize)
                | !c_11 & resM_0[i_14 as usize];
            let mut os_11: *mut uint32_t = resM_0.as_mut_ptr();
            *os_11.offset(i_14 as isize) = x_11;
            i_14 = i_14.wrapping_add(1);
            i_14;
        }
        i1_0 = (i1_0 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t
            as uint32_t;
        let mut c_12: uint32_t = FStar_UInt32_eq_mask(
            bits_c,
            i1_0.wrapping_add(1 as libc::c_uint),
        );
        let mut res_j_12: *const uint32_t = table
            .as_mut_ptr()
            .offset(
                i1_0.wrapping_add(1 as libc::c_uint).wrapping_mul(128 as libc::c_uint)
                    as isize,
            );
        let mut i_15: uint32_t = 0 as libc::c_uint;
        while i_15 < 128 as libc::c_uint {
            let mut x_12: uint32_t = c_12 & *res_j_12.offset(i_15 as isize)
                | !c_12 & resM_0[i_15 as usize];
            let mut os_12: *mut uint32_t = resM_0.as_mut_ptr();
            *os_12.offset(i_15 as isize) = x_12;
            i_15 = i_15.wrapping_add(1);
            i_15;
        }
        i1_0 = (i1_0 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t
            as uint32_t;
        let mut c_13: uint32_t = FStar_UInt32_eq_mask(
            bits_c,
            i1_0.wrapping_add(1 as libc::c_uint),
        );
        let mut res_j_13: *const uint32_t = table
            .as_mut_ptr()
            .offset(
                i1_0.wrapping_add(1 as libc::c_uint).wrapping_mul(128 as libc::c_uint)
                    as isize,
            );
        let mut i_16: uint32_t = 0 as libc::c_uint;
        while i_16 < 128 as libc::c_uint {
            let mut x_13: uint32_t = c_13 & *res_j_13.offset(i_16 as isize)
                | !c_13 & resM_0[i_16 as usize];
            let mut os_13: *mut uint32_t = resM_0.as_mut_ptr();
            *os_13.offset(i_16 as isize) = x_13;
            i_16 = i_16.wrapping_add(1);
            i_16;
        }
        i1_0 = (i1_0 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t
            as uint32_t;
    } else {
        let mut ctx_n_7: *mut uint32_t = ctx_0.as_mut_ptr();
        let mut ctx_r2_0: *mut uint32_t = ctx_0
            .as_mut_ptr()
            .offset(128 as libc::c_uint as isize);
        from(ctx_n_7, mu, ctx_r2_0, resM_0.as_mut_ptr());
    }
    let mut tmp0: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    let mut i0_1: uint32_t = 0 as libc::c_uint;
    while i0_1 < bBits.wrapping_div(4 as libc::c_uint) {
        let mut i_17: uint32_t = 0 as libc::c_uint;
        let mut aM_copy_7: [uint32_t; 128] = [
            0 as libc::c_uint,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
        ];
        memcpy(
            aM_copy_7.as_mut_ptr() as *mut libc::c_void,
            resM_0.as_mut_ptr() as *const libc::c_void,
            (128 as libc::c_uint as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
        );
        let mut ctx_n_8: *mut uint32_t = ctx_0.as_mut_ptr();
        amont_sqr(ctx_n_8, mu, aM_copy_7.as_mut_ptr(), resM_0.as_mut_ptr());
        i_17 = (i_17 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t
            as uint32_t;
        let mut aM_copy_8: [uint32_t; 128] = [
            0 as libc::c_uint,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
        ];
        memcpy(
            aM_copy_8.as_mut_ptr() as *mut libc::c_void,
            resM_0.as_mut_ptr() as *const libc::c_void,
            (128 as libc::c_uint as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
        );
        let mut ctx_n_9: *mut uint32_t = ctx_0.as_mut_ptr();
        amont_sqr(ctx_n_9, mu, aM_copy_8.as_mut_ptr(), resM_0.as_mut_ptr());
        i_17 = (i_17 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t
            as uint32_t;
        let mut aM_copy_9: [uint32_t; 128] = [
            0 as libc::c_uint,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
        ];
        memcpy(
            aM_copy_9.as_mut_ptr() as *mut libc::c_void,
            resM_0.as_mut_ptr() as *const libc::c_void,
            (128 as libc::c_uint as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
        );
        let mut ctx_n_10: *mut uint32_t = ctx_0.as_mut_ptr();
        amont_sqr(ctx_n_10, mu, aM_copy_9.as_mut_ptr(), resM_0.as_mut_ptr());
        i_17 = (i_17 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t
            as uint32_t;
        let mut aM_copy_10: [uint32_t; 128] = [
            0 as libc::c_uint,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
        ];
        memcpy(
            aM_copy_10.as_mut_ptr() as *mut libc::c_void,
            resM_0.as_mut_ptr() as *const libc::c_void,
            (128 as libc::c_uint as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
        );
        let mut ctx_n_11: *mut uint32_t = ctx_0.as_mut_ptr();
        amont_sqr(ctx_n_11, mu, aM_copy_10.as_mut_ptr(), resM_0.as_mut_ptr());
        i_17 = (i_17 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t
            as uint32_t;
        let mut k: uint32_t = bBits
            .wrapping_sub(bBits.wrapping_rem(4 as libc::c_uint))
            .wrapping_sub((4 as libc::c_uint).wrapping_mul(i0_1))
            .wrapping_sub(4 as libc::c_uint);
        let mut bits_l: uint32_t = Hacl_Bignum_Lib_bn_get_bits_u32(
            bLen,
            b,
            k,
            4 as libc::c_uint,
        );
        memcpy(
            tmp0.as_mut_ptr() as *mut libc::c_void,
            table.as_mut_ptr() as *const libc::c_void,
            (128 as libc::c_uint as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
        );
        let mut i1_1: uint32_t = 0 as libc::c_uint;
        let mut c_14: uint32_t = FStar_UInt32_eq_mask(
            bits_l,
            i1_1.wrapping_add(1 as libc::c_uint),
        );
        let mut res_j_14: *const uint32_t = table
            .as_mut_ptr()
            .offset(
                i1_1.wrapping_add(1 as libc::c_uint).wrapping_mul(128 as libc::c_uint)
                    as isize,
            );
        let mut i_18: uint32_t = 0 as libc::c_uint;
        while i_18 < 128 as libc::c_uint {
            let mut x_14: uint32_t = c_14 & *res_j_14.offset(i_18 as isize)
                | !c_14 & tmp0[i_18 as usize];
            let mut os_14: *mut uint32_t = tmp0.as_mut_ptr();
            *os_14.offset(i_18 as isize) = x_14;
            i_18 = i_18.wrapping_add(1);
            i_18;
        }
        i1_1 = (i1_1 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t
            as uint32_t;
        let mut c_15: uint32_t = FStar_UInt32_eq_mask(
            bits_l,
            i1_1.wrapping_add(1 as libc::c_uint),
        );
        let mut res_j_15: *const uint32_t = table
            .as_mut_ptr()
            .offset(
                i1_1.wrapping_add(1 as libc::c_uint).wrapping_mul(128 as libc::c_uint)
                    as isize,
            );
        let mut i_19: uint32_t = 0 as libc::c_uint;
        while i_19 < 128 as libc::c_uint {
            let mut x_15: uint32_t = c_15 & *res_j_15.offset(i_19 as isize)
                | !c_15 & tmp0[i_19 as usize];
            let mut os_15: *mut uint32_t = tmp0.as_mut_ptr();
            *os_15.offset(i_19 as isize) = x_15;
            i_19 = i_19.wrapping_add(1);
            i_19;
        }
        i1_1 = (i1_1 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t
            as uint32_t;
        let mut c_16: uint32_t = FStar_UInt32_eq_mask(
            bits_l,
            i1_1.wrapping_add(1 as libc::c_uint),
        );
        let mut res_j_16: *const uint32_t = table
            .as_mut_ptr()
            .offset(
                i1_1.wrapping_add(1 as libc::c_uint).wrapping_mul(128 as libc::c_uint)
                    as isize,
            );
        let mut i_20: uint32_t = 0 as libc::c_uint;
        while i_20 < 128 as libc::c_uint {
            let mut x_16: uint32_t = c_16 & *res_j_16.offset(i_20 as isize)
                | !c_16 & tmp0[i_20 as usize];
            let mut os_16: *mut uint32_t = tmp0.as_mut_ptr();
            *os_16.offset(i_20 as isize) = x_16;
            i_20 = i_20.wrapping_add(1);
            i_20;
        }
        i1_1 = (i1_1 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t
            as uint32_t;
        let mut c_17: uint32_t = FStar_UInt32_eq_mask(
            bits_l,
            i1_1.wrapping_add(1 as libc::c_uint),
        );
        let mut res_j_17: *const uint32_t = table
            .as_mut_ptr()
            .offset(
                i1_1.wrapping_add(1 as libc::c_uint).wrapping_mul(128 as libc::c_uint)
                    as isize,
            );
        let mut i_21: uint32_t = 0 as libc::c_uint;
        while i_21 < 128 as libc::c_uint {
            let mut x_17: uint32_t = c_17 & *res_j_17.offset(i_21 as isize)
                | !c_17 & tmp0[i_21 as usize];
            let mut os_17: *mut uint32_t = tmp0.as_mut_ptr();
            *os_17.offset(i_21 as isize) = x_17;
            i_21 = i_21.wrapping_add(1);
            i_21;
        }
        i1_1 = (i1_1 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t
            as uint32_t;
        let mut c_18: uint32_t = FStar_UInt32_eq_mask(
            bits_l,
            i1_1.wrapping_add(1 as libc::c_uint),
        );
        let mut res_j_18: *const uint32_t = table
            .as_mut_ptr()
            .offset(
                i1_1.wrapping_add(1 as libc::c_uint).wrapping_mul(128 as libc::c_uint)
                    as isize,
            );
        let mut i_22: uint32_t = 0 as libc::c_uint;
        while i_22 < 128 as libc::c_uint {
            let mut x_18: uint32_t = c_18 & *res_j_18.offset(i_22 as isize)
                | !c_18 & tmp0[i_22 as usize];
            let mut os_18: *mut uint32_t = tmp0.as_mut_ptr();
            *os_18.offset(i_22 as isize) = x_18;
            i_22 = i_22.wrapping_add(1);
            i_22;
        }
        i1_1 = (i1_1 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t
            as uint32_t;
        let mut c_19: uint32_t = FStar_UInt32_eq_mask(
            bits_l,
            i1_1.wrapping_add(1 as libc::c_uint),
        );
        let mut res_j_19: *const uint32_t = table
            .as_mut_ptr()
            .offset(
                i1_1.wrapping_add(1 as libc::c_uint).wrapping_mul(128 as libc::c_uint)
                    as isize,
            );
        let mut i_23: uint32_t = 0 as libc::c_uint;
        while i_23 < 128 as libc::c_uint {
            let mut x_19: uint32_t = c_19 & *res_j_19.offset(i_23 as isize)
                | !c_19 & tmp0[i_23 as usize];
            let mut os_19: *mut uint32_t = tmp0.as_mut_ptr();
            *os_19.offset(i_23 as isize) = x_19;
            i_23 = i_23.wrapping_add(1);
            i_23;
        }
        i1_1 = (i1_1 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t
            as uint32_t;
        let mut c_20: uint32_t = FStar_UInt32_eq_mask(
            bits_l,
            i1_1.wrapping_add(1 as libc::c_uint),
        );
        let mut res_j_20: *const uint32_t = table
            .as_mut_ptr()
            .offset(
                i1_1.wrapping_add(1 as libc::c_uint).wrapping_mul(128 as libc::c_uint)
                    as isize,
            );
        let mut i_24: uint32_t = 0 as libc::c_uint;
        while i_24 < 128 as libc::c_uint {
            let mut x_20: uint32_t = c_20 & *res_j_20.offset(i_24 as isize)
                | !c_20 & tmp0[i_24 as usize];
            let mut os_20: *mut uint32_t = tmp0.as_mut_ptr();
            *os_20.offset(i_24 as isize) = x_20;
            i_24 = i_24.wrapping_add(1);
            i_24;
        }
        i1_1 = (i1_1 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t
            as uint32_t;
        let mut c_21: uint32_t = FStar_UInt32_eq_mask(
            bits_l,
            i1_1.wrapping_add(1 as libc::c_uint),
        );
        let mut res_j_21: *const uint32_t = table
            .as_mut_ptr()
            .offset(
                i1_1.wrapping_add(1 as libc::c_uint).wrapping_mul(128 as libc::c_uint)
                    as isize,
            );
        let mut i_25: uint32_t = 0 as libc::c_uint;
        while i_25 < 128 as libc::c_uint {
            let mut x_21: uint32_t = c_21 & *res_j_21.offset(i_25 as isize)
                | !c_21 & tmp0[i_25 as usize];
            let mut os_21: *mut uint32_t = tmp0.as_mut_ptr();
            *os_21.offset(i_25 as isize) = x_21;
            i_25 = i_25.wrapping_add(1);
            i_25;
        }
        i1_1 = (i1_1 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t
            as uint32_t;
        let mut c_22: uint32_t = FStar_UInt32_eq_mask(
            bits_l,
            i1_1.wrapping_add(1 as libc::c_uint),
        );
        let mut res_j_22: *const uint32_t = table
            .as_mut_ptr()
            .offset(
                i1_1.wrapping_add(1 as libc::c_uint).wrapping_mul(128 as libc::c_uint)
                    as isize,
            );
        let mut i_26: uint32_t = 0 as libc::c_uint;
        while i_26 < 128 as libc::c_uint {
            let mut x_22: uint32_t = c_22 & *res_j_22.offset(i_26 as isize)
                | !c_22 & tmp0[i_26 as usize];
            let mut os_22: *mut uint32_t = tmp0.as_mut_ptr();
            *os_22.offset(i_26 as isize) = x_22;
            i_26 = i_26.wrapping_add(1);
            i_26;
        }
        i1_1 = (i1_1 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t
            as uint32_t;
        let mut c_23: uint32_t = FStar_UInt32_eq_mask(
            bits_l,
            i1_1.wrapping_add(1 as libc::c_uint),
        );
        let mut res_j_23: *const uint32_t = table
            .as_mut_ptr()
            .offset(
                i1_1.wrapping_add(1 as libc::c_uint).wrapping_mul(128 as libc::c_uint)
                    as isize,
            );
        let mut i_27: uint32_t = 0 as libc::c_uint;
        while i_27 < 128 as libc::c_uint {
            let mut x_23: uint32_t = c_23 & *res_j_23.offset(i_27 as isize)
                | !c_23 & tmp0[i_27 as usize];
            let mut os_23: *mut uint32_t = tmp0.as_mut_ptr();
            *os_23.offset(i_27 as isize) = x_23;
            i_27 = i_27.wrapping_add(1);
            i_27;
        }
        i1_1 = (i1_1 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t
            as uint32_t;
        let mut c_24: uint32_t = FStar_UInt32_eq_mask(
            bits_l,
            i1_1.wrapping_add(1 as libc::c_uint),
        );
        let mut res_j_24: *const uint32_t = table
            .as_mut_ptr()
            .offset(
                i1_1.wrapping_add(1 as libc::c_uint).wrapping_mul(128 as libc::c_uint)
                    as isize,
            );
        let mut i_28: uint32_t = 0 as libc::c_uint;
        while i_28 < 128 as libc::c_uint {
            let mut x_24: uint32_t = c_24 & *res_j_24.offset(i_28 as isize)
                | !c_24 & tmp0[i_28 as usize];
            let mut os_24: *mut uint32_t = tmp0.as_mut_ptr();
            *os_24.offset(i_28 as isize) = x_24;
            i_28 = i_28.wrapping_add(1);
            i_28;
        }
        i1_1 = (i1_1 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t
            as uint32_t;
        let mut c_25: uint32_t = FStar_UInt32_eq_mask(
            bits_l,
            i1_1.wrapping_add(1 as libc::c_uint),
        );
        let mut res_j_25: *const uint32_t = table
            .as_mut_ptr()
            .offset(
                i1_1.wrapping_add(1 as libc::c_uint).wrapping_mul(128 as libc::c_uint)
                    as isize,
            );
        let mut i_29: uint32_t = 0 as libc::c_uint;
        while i_29 < 128 as libc::c_uint {
            let mut x_25: uint32_t = c_25 & *res_j_25.offset(i_29 as isize)
                | !c_25 & tmp0[i_29 as usize];
            let mut os_25: *mut uint32_t = tmp0.as_mut_ptr();
            *os_25.offset(i_29 as isize) = x_25;
            i_29 = i_29.wrapping_add(1);
            i_29;
        }
        i1_1 = (i1_1 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t
            as uint32_t;
        let mut c_26: uint32_t = FStar_UInt32_eq_mask(
            bits_l,
            i1_1.wrapping_add(1 as libc::c_uint),
        );
        let mut res_j_26: *const uint32_t = table
            .as_mut_ptr()
            .offset(
                i1_1.wrapping_add(1 as libc::c_uint).wrapping_mul(128 as libc::c_uint)
                    as isize,
            );
        let mut i_30: uint32_t = 0 as libc::c_uint;
        while i_30 < 128 as libc::c_uint {
            let mut x_26: uint32_t = c_26 & *res_j_26.offset(i_30 as isize)
                | !c_26 & tmp0[i_30 as usize];
            let mut os_26: *mut uint32_t = tmp0.as_mut_ptr();
            *os_26.offset(i_30 as isize) = x_26;
            i_30 = i_30.wrapping_add(1);
            i_30;
        }
        i1_1 = (i1_1 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t
            as uint32_t;
        let mut c_27: uint32_t = FStar_UInt32_eq_mask(
            bits_l,
            i1_1.wrapping_add(1 as libc::c_uint),
        );
        let mut res_j_27: *const uint32_t = table
            .as_mut_ptr()
            .offset(
                i1_1.wrapping_add(1 as libc::c_uint).wrapping_mul(128 as libc::c_uint)
                    as isize,
            );
        let mut i_31: uint32_t = 0 as libc::c_uint;
        while i_31 < 128 as libc::c_uint {
            let mut x_27: uint32_t = c_27 & *res_j_27.offset(i_31 as isize)
                | !c_27 & tmp0[i_31 as usize];
            let mut os_27: *mut uint32_t = tmp0.as_mut_ptr();
            *os_27.offset(i_31 as isize) = x_27;
            i_31 = i_31.wrapping_add(1);
            i_31;
        }
        i1_1 = (i1_1 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t
            as uint32_t;
        let mut c_28: uint32_t = FStar_UInt32_eq_mask(
            bits_l,
            i1_1.wrapping_add(1 as libc::c_uint),
        );
        let mut res_j_28: *const uint32_t = table
            .as_mut_ptr()
            .offset(
                i1_1.wrapping_add(1 as libc::c_uint).wrapping_mul(128 as libc::c_uint)
                    as isize,
            );
        let mut i_32: uint32_t = 0 as libc::c_uint;
        while i_32 < 128 as libc::c_uint {
            let mut x_28: uint32_t = c_28 & *res_j_28.offset(i_32 as isize)
                | !c_28 & tmp0[i_32 as usize];
            let mut os_28: *mut uint32_t = tmp0.as_mut_ptr();
            *os_28.offset(i_32 as isize) = x_28;
            i_32 = i_32.wrapping_add(1);
            i_32;
        }
        i1_1 = (i1_1 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t
            as uint32_t;
        let mut aM_copy_11: [uint32_t; 128] = [
            0 as libc::c_uint,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
        ];
        memcpy(
            aM_copy_11.as_mut_ptr() as *mut libc::c_void,
            resM_0.as_mut_ptr() as *const libc::c_void,
            (128 as libc::c_uint as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
        );
        let mut ctx_n_12: *mut uint32_t = ctx_0.as_mut_ptr();
        amont_mul(
            ctx_n_12,
            mu,
            aM_copy_11.as_mut_ptr(),
            tmp0.as_mut_ptr(),
            resM_0.as_mut_ptr(),
        );
        i0_1 = i0_1.wrapping_add(1);
        i0_1;
    }
    from(n, mu, resM_0.as_mut_ptr(), res);
}
#[inline]
unsafe extern "C" fn exp_vartime(
    mut nBits: uint32_t,
    mut n: *mut uint32_t,
    mut a: *mut uint32_t,
    mut bBits: uint32_t,
    mut b: *mut uint32_t,
    mut res: *mut uint32_t,
) {
    let mut r2: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    precompr2(nBits, n, r2.as_mut_ptr());
    let mut mu: uint32_t = Hacl_Bignum_ModInvLimb_mod_inv_uint32(
        *n.offset(0 as libc::c_uint as isize),
    );
    exp_vartime_precomp(n, mu, r2.as_mut_ptr(), a, bBits, b, res);
}
#[inline]
unsafe extern "C" fn exp_consttime(
    mut nBits: uint32_t,
    mut n: *mut uint32_t,
    mut a: *mut uint32_t,
    mut bBits: uint32_t,
    mut b: *mut uint32_t,
    mut res: *mut uint32_t,
) {
    let mut r2: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    precompr2(nBits, n, r2.as_mut_ptr());
    let mut mu: uint32_t = Hacl_Bignum_ModInvLimb_mod_inv_uint32(
        *n.offset(0 as libc::c_uint as isize),
    );
    exp_consttime_precomp(n, mu, r2.as_mut_ptr(), a, bBits, b, res);
}
#[no_mangle]
pub unsafe extern "C" fn Hacl_Bignum4096_32_mod_exp_vartime(
    mut n: *mut uint32_t,
    mut a: *mut uint32_t,
    mut bBits: uint32_t,
    mut b: *mut uint32_t,
    mut res: *mut uint32_t,
) -> bool {
    let mut is_valid_m: uint32_t = exp_check(n, a, bBits, b);
    let mut nBits: uint32_t = (32 as libc::c_uint)
        .wrapping_mul(Hacl_Bignum_Lib_bn_get_top_index_u32(128 as libc::c_uint, n));
    if is_valid_m == 0xffffffff as libc::c_uint {
        exp_vartime(nBits, n, a, bBits, b, res);
    } else {
        memset(
            res as *mut libc::c_void,
            0 as libc::c_uint as libc::c_int,
            (128 as libc::c_uint as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
        );
    }
    return is_valid_m == 0xffffffff as libc::c_uint;
}
#[no_mangle]
pub unsafe extern "C" fn Hacl_Bignum4096_32_mod_exp_consttime(
    mut n: *mut uint32_t,
    mut a: *mut uint32_t,
    mut bBits: uint32_t,
    mut b: *mut uint32_t,
    mut res: *mut uint32_t,
) -> bool {
    let mut is_valid_m: uint32_t = exp_check(n, a, bBits, b);
    let mut nBits: uint32_t = (32 as libc::c_uint)
        .wrapping_mul(Hacl_Bignum_Lib_bn_get_top_index_u32(128 as libc::c_uint, n));
    if is_valid_m == 0xffffffff as libc::c_uint {
        exp_consttime(nBits, n, a, bBits, b, res);
    } else {
        memset(
            res as *mut libc::c_void,
            0 as libc::c_uint as libc::c_int,
            (128 as libc::c_uint as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
        );
    }
    return is_valid_m == 0xffffffff as libc::c_uint;
}
#[no_mangle]
pub unsafe extern "C" fn Hacl_Bignum4096_32_mod_inv_prime_vartime(
    mut n: *mut uint32_t,
    mut a: *mut uint32_t,
    mut res: *mut uint32_t,
) -> bool {
    let mut one: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    memset(
        one.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_uint as libc::c_int,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    one[0 as libc::c_uint as usize] = 1 as libc::c_uint;
    let mut bit0: uint32_t = *n.offset(0 as libc::c_uint as isize) & 1 as libc::c_uint;
    let mut m0: uint32_t = (0 as libc::c_uint).wrapping_sub(bit0);
    let mut acc0: uint32_t = 0 as libc::c_uint;
    let mut i: uint32_t = 0 as libc::c_uint;
    while i < 128 as libc::c_uint {
        let mut beq: uint32_t = FStar_UInt32_eq_mask(
            one[i as usize],
            *n.offset(i as isize),
        );
        let mut blt: uint32_t = !FStar_UInt32_gte_mask(
            one[i as usize],
            *n.offset(i as isize),
        );
        acc0 = beq & acc0 | !beq & blt;
        i = i.wrapping_add(1);
        i;
    }
    let mut m1: uint32_t = acc0;
    let mut m00: uint32_t = m0 & m1;
    let mut bn_zero: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    let mut mask: uint32_t = 0xffffffff as libc::c_uint;
    let mut i_0: uint32_t = 0 as libc::c_uint;
    while i_0 < 128 as libc::c_uint {
        let mut uu____0: uint32_t = FStar_UInt32_eq_mask(
            *a.offset(i_0 as isize),
            bn_zero[i_0 as usize],
        );
        mask = uu____0 & mask;
        i_0 = i_0.wrapping_add(1);
        i_0;
    }
    let mut mask1: uint32_t = mask;
    let mut res10: uint32_t = mask1;
    let mut m10: uint32_t = res10;
    let mut acc: uint32_t = 0 as libc::c_uint;
    let mut i_1: uint32_t = 0 as libc::c_uint;
    while i_1 < 128 as libc::c_uint {
        let mut beq_0: uint32_t = FStar_UInt32_eq_mask(
            *a.offset(i_1 as isize),
            *n.offset(i_1 as isize),
        );
        let mut blt_0: uint32_t = !FStar_UInt32_gte_mask(
            *a.offset(i_1 as isize),
            *n.offset(i_1 as isize),
        );
        acc = beq_0 & acc | !beq_0 & blt_0;
        i_1 = i_1.wrapping_add(1);
        i_1;
    }
    let mut m2: uint32_t = acc;
    let mut is_valid_m: uint32_t = m00 & !m10 & m2;
    let mut nBits: uint32_t = (32 as libc::c_uint)
        .wrapping_mul(Hacl_Bignum_Lib_bn_get_top_index_u32(128 as libc::c_uint, n));
    if is_valid_m == 0xffffffff as libc::c_uint {
        let mut n2: [uint32_t; 128] = [
            0 as libc::c_uint,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
        ];
        let mut c0: uint32_t = Hacl_IntTypes_Intrinsics_sub_borrow_u32(
            0 as libc::c_uint,
            *n.offset(0 as libc::c_uint as isize),
            2 as libc::c_uint,
            n2.as_mut_ptr(),
        );
        let mut a1: *mut uint32_t = n.offset(1 as libc::c_uint as isize);
        let mut res1: *mut uint32_t = n2.as_mut_ptr().offset(1 as libc::c_uint as isize);
        let mut c: uint32_t = c0;
        let mut i_2: uint32_t = 0 as libc::c_uint;
        while i_2 < 31 as libc::c_uint {
            let mut t1: uint32_t = *a1
                .offset((4 as libc::c_uint).wrapping_mul(i_2) as isize);
            let mut res_i0: *mut uint32_t = res1
                .offset((4 as libc::c_uint).wrapping_mul(i_2) as isize);
            c = Hacl_IntTypes_Intrinsics_sub_borrow_u32(
                c,
                t1,
                0 as libc::c_uint,
                res_i0,
            );
            let mut t10: uint32_t = *a1
                .offset(
                    (4 as libc::c_uint).wrapping_mul(i_2).wrapping_add(1 as libc::c_uint)
                        as isize,
                );
            let mut res_i1: *mut uint32_t = res1
                .offset((4 as libc::c_uint).wrapping_mul(i_2) as isize)
                .offset(1 as libc::c_uint as isize);
            c = Hacl_IntTypes_Intrinsics_sub_borrow_u32(
                c,
                t10,
                0 as libc::c_uint,
                res_i1,
            );
            let mut t11: uint32_t = *a1
                .offset(
                    (4 as libc::c_uint).wrapping_mul(i_2).wrapping_add(2 as libc::c_uint)
                        as isize,
                );
            let mut res_i2: *mut uint32_t = res1
                .offset((4 as libc::c_uint).wrapping_mul(i_2) as isize)
                .offset(2 as libc::c_uint as isize);
            c = Hacl_IntTypes_Intrinsics_sub_borrow_u32(
                c,
                t11,
                0 as libc::c_uint,
                res_i2,
            );
            let mut t12: uint32_t = *a1
                .offset(
                    (4 as libc::c_uint).wrapping_mul(i_2).wrapping_add(3 as libc::c_uint)
                        as isize,
                );
            let mut res_i: *mut uint32_t = res1
                .offset((4 as libc::c_uint).wrapping_mul(i_2) as isize)
                .offset(3 as libc::c_uint as isize);
            c = Hacl_IntTypes_Intrinsics_sub_borrow_u32(
                c,
                t12,
                0 as libc::c_uint,
                res_i,
            );
            i_2 = i_2.wrapping_add(1);
            i_2;
        }
        let mut i_3: uint32_t = 124 as libc::c_uint;
        let mut t1_0: uint32_t = *a1.offset(i_3 as isize);
        let mut res_i_0: *mut uint32_t = res1.offset(i_3 as isize);
        c = Hacl_IntTypes_Intrinsics_sub_borrow_u32(c, t1_0, 0 as libc::c_uint, res_i_0);
        i_3 = (i_3 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t
            as uint32_t;
        let mut t1_1: uint32_t = *a1.offset(i_3 as isize);
        let mut res_i_1: *mut uint32_t = res1.offset(i_3 as isize);
        c = Hacl_IntTypes_Intrinsics_sub_borrow_u32(c, t1_1, 0 as libc::c_uint, res_i_1);
        i_3 = (i_3 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t
            as uint32_t;
        let mut t1_2: uint32_t = *a1.offset(i_3 as isize);
        let mut res_i_2: *mut uint32_t = res1.offset(i_3 as isize);
        c = Hacl_IntTypes_Intrinsics_sub_borrow_u32(c, t1_2, 0 as libc::c_uint, res_i_2);
        i_3 = (i_3 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t
            as uint32_t;
        let mut c1: uint32_t = c;
        let mut c2: uint32_t = c1;
        exp_vartime(nBits, n, a, 4096 as libc::c_uint, n2.as_mut_ptr(), res);
    } else {
        memset(
            res as *mut libc::c_void,
            0 as libc::c_uint as libc::c_int,
            (128 as libc::c_uint as libc::c_ulong)
                .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
        );
    }
    return is_valid_m == 0xffffffff as libc::c_uint;
}
#[no_mangle]
pub unsafe extern "C" fn Hacl_Bignum4096_32_mont_ctx_init(
    mut n: *mut uint32_t,
) -> *mut Hacl_Bignum_MontArithmetic_bn_mont_ctx_u32 {
    let mut r2: *mut uint32_t = calloc(
        128 as libc::c_uint as libc::c_ulong,
        ::core::mem::size_of::<uint32_t>() as libc::c_ulong,
    ) as *mut uint32_t;
    let mut n1: *mut uint32_t = calloc(
        128 as libc::c_uint as libc::c_ulong,
        ::core::mem::size_of::<uint32_t>() as libc::c_ulong,
    ) as *mut uint32_t;
    let mut r21: *mut uint32_t = r2;
    let mut n11: *mut uint32_t = n1;
    memcpy(
        n11 as *mut libc::c_void,
        n as *const libc::c_void,
        (128 as libc::c_uint as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint32_t>() as libc::c_ulong),
    );
    let mut nBits: uint32_t = (32 as libc::c_uint)
        .wrapping_mul(Hacl_Bignum_Lib_bn_get_top_index_u32(128 as libc::c_uint, n));
    precompr2(nBits, n, r21);
    let mut mu: uint32_t = Hacl_Bignum_ModInvLimb_mod_inv_uint32(
        *n.offset(0 as libc::c_uint as isize),
    );
    let mut res: Hacl_Bignum_MontArithmetic_bn_mont_ctx_u32 = {
        let mut init = Hacl_Bignum_MontArithmetic_bn_mont_ctx_u32_s {
            len: 128 as libc::c_uint,
            n: n11,
            mu: mu,
            r2: r21,
        };
        init
    };
    let mut buf: *mut Hacl_Bignum_MontArithmetic_bn_mont_ctx_u32 = malloc(
        ::core::mem::size_of::<Hacl_Bignum_MontArithmetic_bn_mont_ctx_u32>()
            as libc::c_ulong,
    ) as *mut Hacl_Bignum_MontArithmetic_bn_mont_ctx_u32;
    *buf.offset(0 as libc::c_uint as isize) = res;
    return buf;
}
#[no_mangle]
pub unsafe extern "C" fn Hacl_Bignum4096_32_mont_ctx_free(
    mut k: *mut Hacl_Bignum_MontArithmetic_bn_mont_ctx_u32,
) {
    let mut uu____0: Hacl_Bignum_MontArithmetic_bn_mont_ctx_u32 = *k;
    let mut n: *mut uint32_t = uu____0.n;
    let mut r2: *mut uint32_t = uu____0.r2;
    free(n as *mut libc::c_void);
    free(r2 as *mut libc::c_void);
    free(k as *mut libc::c_void);
}
#[no_mangle]
pub unsafe extern "C" fn Hacl_Bignum4096_32_mod_precomp(
    mut k: *mut Hacl_Bignum_MontArithmetic_bn_mont_ctx_u32,
    mut a: *mut uint32_t,
    mut res: *mut uint32_t,
) {
    let mut n: *mut uint32_t = (*k).n;
    let mut mu: uint32_t = (*k).mu;
    let mut r2: *mut uint32_t = (*k).r2;
    bn_slow_precomp(n, mu, r2, a, res);
}
#[no_mangle]
pub unsafe extern "C" fn Hacl_Bignum4096_32_mod_exp_vartime_precomp(
    mut k: *mut Hacl_Bignum_MontArithmetic_bn_mont_ctx_u32,
    mut a: *mut uint32_t,
    mut bBits: uint32_t,
    mut b: *mut uint32_t,
    mut res: *mut uint32_t,
) {
    let mut n: *mut uint32_t = (*k).n;
    let mut mu: uint32_t = (*k).mu;
    let mut r2: *mut uint32_t = (*k).r2;
    exp_vartime_precomp(n, mu, r2, a, bBits, b, res);
}
#[no_mangle]
pub unsafe extern "C" fn Hacl_Bignum4096_32_mod_exp_consttime_precomp(
    mut k: *mut Hacl_Bignum_MontArithmetic_bn_mont_ctx_u32,
    mut a: *mut uint32_t,
    mut bBits: uint32_t,
    mut b: *mut uint32_t,
    mut res: *mut uint32_t,
) {
    let mut n: *mut uint32_t = (*k).n;
    let mut mu: uint32_t = (*k).mu;
    let mut r2: *mut uint32_t = (*k).r2;
    exp_consttime_precomp(n, mu, r2, a, bBits, b, res);
}
#[no_mangle]
pub unsafe extern "C" fn Hacl_Bignum4096_32_mod_inv_prime_vartime_precomp(
    mut k: *mut Hacl_Bignum_MontArithmetic_bn_mont_ctx_u32,
    mut a: *mut uint32_t,
    mut res: *mut uint32_t,
) {
    let mut n: *mut uint32_t = (*k).n;
    let mut mu: uint32_t = (*k).mu;
    let mut r2: *mut uint32_t = (*k).r2;
    let mut n2: [uint32_t; 128] = [
        0 as libc::c_uint,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    let mut c0: uint32_t = Hacl_IntTypes_Intrinsics_sub_borrow_u32(
        0 as libc::c_uint,
        *n.offset(0 as libc::c_uint as isize),
        2 as libc::c_uint,
        n2.as_mut_ptr(),
    );
    let mut a1: *mut uint32_t = n.offset(1 as libc::c_uint as isize);
    let mut res1: *mut uint32_t = n2.as_mut_ptr().offset(1 as libc::c_uint as isize);
    let mut c: uint32_t = c0;
    let mut i: uint32_t = 0 as libc::c_uint;
    while i < 31 as libc::c_uint {
        let mut t1: uint32_t = *a1.offset((4 as libc::c_uint).wrapping_mul(i) as isize);
        let mut res_i0: *mut uint32_t = res1
            .offset((4 as libc::c_uint).wrapping_mul(i) as isize);
        c = Hacl_IntTypes_Intrinsics_sub_borrow_u32(c, t1, 0 as libc::c_uint, res_i0);
        let mut t10: uint32_t = *a1
            .offset(
                (4 as libc::c_uint).wrapping_mul(i).wrapping_add(1 as libc::c_uint)
                    as isize,
            );
        let mut res_i1: *mut uint32_t = res1
            .offset((4 as libc::c_uint).wrapping_mul(i) as isize)
            .offset(1 as libc::c_uint as isize);
        c = Hacl_IntTypes_Intrinsics_sub_borrow_u32(c, t10, 0 as libc::c_uint, res_i1);
        let mut t11: uint32_t = *a1
            .offset(
                (4 as libc::c_uint).wrapping_mul(i).wrapping_add(2 as libc::c_uint)
                    as isize,
            );
        let mut res_i2: *mut uint32_t = res1
            .offset((4 as libc::c_uint).wrapping_mul(i) as isize)
            .offset(2 as libc::c_uint as isize);
        c = Hacl_IntTypes_Intrinsics_sub_borrow_u32(c, t11, 0 as libc::c_uint, res_i2);
        let mut t12: uint32_t = *a1
            .offset(
                (4 as libc::c_uint).wrapping_mul(i).wrapping_add(3 as libc::c_uint)
                    as isize,
            );
        let mut res_i: *mut uint32_t = res1
            .offset((4 as libc::c_uint).wrapping_mul(i) as isize)
            .offset(3 as libc::c_uint as isize);
        c = Hacl_IntTypes_Intrinsics_sub_borrow_u32(c, t12, 0 as libc::c_uint, res_i);
        i = i.wrapping_add(1);
        i;
    }
    let mut i_0: uint32_t = 124 as libc::c_uint;
    let mut t1_0: uint32_t = *a1.offset(i_0 as isize);
    let mut res_i_0: *mut uint32_t = res1.offset(i_0 as isize);
    c = Hacl_IntTypes_Intrinsics_sub_borrow_u32(c, t1_0, 0 as libc::c_uint, res_i_0);
    i_0 = (i_0 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t as uint32_t;
    let mut t1_1: uint32_t = *a1.offset(i_0 as isize);
    let mut res_i_1: *mut uint32_t = res1.offset(i_0 as isize);
    c = Hacl_IntTypes_Intrinsics_sub_borrow_u32(c, t1_1, 0 as libc::c_uint, res_i_1);
    i_0 = (i_0 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t as uint32_t;
    let mut t1_2: uint32_t = *a1.offset(i_0 as isize);
    let mut res_i_2: *mut uint32_t = res1.offset(i_0 as isize);
    c = Hacl_IntTypes_Intrinsics_sub_borrow_u32(c, t1_2, 0 as libc::c_uint, res_i_2);
    i_0 = (i_0 as libc::c_uint).wrapping_add(1 as libc::c_uint) as uint32_t as uint32_t;
    let mut c1: uint32_t = c;
    let mut c2: uint32_t = c1;
    exp_vartime_precomp(n, mu, r2, a, 4096 as libc::c_uint, n2.as_mut_ptr(), res);
}
#[no_mangle]
pub unsafe extern "C" fn Hacl_Bignum4096_32_new_bn_from_bytes_be(
    mut len: uint32_t,
    mut b: *mut uint8_t,
) -> *mut uint32_t {
    if len == 0 as libc::c_uint
        || !(len
            .wrapping_sub(1 as libc::c_uint)
            .wrapping_div(4 as libc::c_uint)
            .wrapping_add(1 as libc::c_uint) <= 1073741823 as libc::c_uint)
    {
        return 0 as *mut uint32_t;
    }
    if len
        .wrapping_sub(1 as libc::c_uint)
        .wrapping_div(4 as libc::c_uint)
        .wrapping_add(1 as libc::c_uint) as size_t
        > (18446744073709551615 as libc::c_ulong)
            .wrapping_div(::core::mem::size_of::<uint32_t>() as libc::c_ulong)
    {
        printf(
            b"Maximum allocatable size exceeded, aborting before overflow at %s:%d\n\0"
                as *const u8 as *const libc::c_char,
            b"Hacl_Bignum4096_32.c\0" as *const u8 as *const libc::c_char,
            1261 as libc::c_int,
        );
        exit(253 as libc::c_int);
    }
    let mut res: *mut uint32_t = calloc(
        len
            .wrapping_sub(1 as libc::c_uint)
            .wrapping_div(4 as libc::c_uint)
            .wrapping_add(1 as libc::c_uint) as libc::c_ulong,
        ::core::mem::size_of::<uint32_t>() as libc::c_ulong,
    ) as *mut uint32_t;
    if res.is_null() {
        return res;
    }
    let mut res1: *mut uint32_t = res;
    let mut res2: *mut uint32_t = res1;
    let mut bnLen: uint32_t = len
        .wrapping_sub(1 as libc::c_uint)
        .wrapping_div(4 as libc::c_uint)
        .wrapping_add(1 as libc::c_uint);
    let mut tmpLen: uint32_t = (4 as libc::c_uint).wrapping_mul(bnLen);
    if tmpLen as size_t
        > (18446744073709551615 as libc::c_ulong)
            .wrapping_div(::core::mem::size_of::<uint8_t>() as libc::c_ulong)
    {
        printf(
            b"Maximum allocatable size exceeded, aborting before overflow at %s:%d\n\0"
                as *const u8 as *const libc::c_char,
            b"Hacl_Bignum4096_32.c\0" as *const u8 as *const libc::c_char,
            1271 as libc::c_int,
        );
        exit(253 as libc::c_int);
    }
    let vla = tmpLen as usize;
    let mut tmp: Vec::<uint8_t> = ::std::vec::from_elem(0, vla);
    memset(
        tmp.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_uint as libc::c_int,
        (tmpLen as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint8_t>() as libc::c_ulong),
    );
    memcpy(
        tmp.as_mut_ptr().offset(tmpLen as isize).offset(-(len as isize))
            as *mut libc::c_void,
        b as *const libc::c_void,
        (len as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint8_t>() as libc::c_ulong),
    );
    let mut i: uint32_t = 0 as libc::c_uint;
    while i < bnLen {
        let mut u: uint32_t = if 0 != 0 {
            (load32(
                tmp
                    .as_mut_ptr()
                    .offset(
                        bnLen
                            .wrapping_sub(i)
                            .wrapping_sub(1 as libc::c_uint)
                            .wrapping_mul(4 as libc::c_uint) as isize,
                    ),
            ) & 0xff000000 as libc::c_uint) >> 24 as libc::c_int
                | (load32(
                    tmp
                        .as_mut_ptr()
                        .offset(
                            bnLen
                                .wrapping_sub(i)
                                .wrapping_sub(1 as libc::c_uint)
                                .wrapping_mul(4 as libc::c_uint) as isize,
                        ),
                ) & 0xff0000 as libc::c_uint) >> 8 as libc::c_int
                | (load32(
                    tmp
                        .as_mut_ptr()
                        .offset(
                            bnLen
                                .wrapping_sub(i)
                                .wrapping_sub(1 as libc::c_uint)
                                .wrapping_mul(4 as libc::c_uint) as isize,
                        ),
                ) & 0xff00 as libc::c_uint) << 8 as libc::c_int
                | (load32(
                    tmp
                        .as_mut_ptr()
                        .offset(
                            bnLen
                                .wrapping_sub(i)
                                .wrapping_sub(1 as libc::c_uint)
                                .wrapping_mul(4 as libc::c_uint) as isize,
                        ),
                ) & 0xff as libc::c_uint) << 24 as libc::c_int
        } else {
            _OSSwapInt32(
                load32(
                    tmp
                        .as_mut_ptr()
                        .offset(
                            bnLen
                                .wrapping_sub(i)
                                .wrapping_sub(1 as libc::c_uint)
                                .wrapping_mul(4 as libc::c_uint) as isize,
                        ),
                ),
            )
        };
        let mut x: uint32_t = u;
        let mut os: *mut uint32_t = res2;
        *os.offset(i as isize) = x;
        i = i.wrapping_add(1);
        i;
    }
    return res2;
}
#[no_mangle]
pub unsafe extern "C" fn Hacl_Bignum4096_32_new_bn_from_bytes_le(
    mut len: uint32_t,
    mut b: *mut uint8_t,
) -> *mut uint32_t {
    if len == 0 as libc::c_uint
        || !(len
            .wrapping_sub(1 as libc::c_uint)
            .wrapping_div(4 as libc::c_uint)
            .wrapping_add(1 as libc::c_uint) <= 1073741823 as libc::c_uint)
    {
        return 0 as *mut uint32_t;
    }
    if len
        .wrapping_sub(1 as libc::c_uint)
        .wrapping_div(4 as libc::c_uint)
        .wrapping_add(1 as libc::c_uint) as size_t
        > (18446744073709551615 as libc::c_ulong)
            .wrapping_div(::core::mem::size_of::<uint32_t>() as libc::c_ulong)
    {
        printf(
            b"Maximum allocatable size exceeded, aborting before overflow at %s:%d\n\0"
                as *const u8 as *const libc::c_char,
            b"Hacl_Bignum4096_32.c\0" as *const u8 as *const libc::c_char,
            1302 as libc::c_int,
        );
        exit(253 as libc::c_int);
    }
    let mut res: *mut uint32_t = calloc(
        len
            .wrapping_sub(1 as libc::c_uint)
            .wrapping_div(4 as libc::c_uint)
            .wrapping_add(1 as libc::c_uint) as libc::c_ulong,
        ::core::mem::size_of::<uint32_t>() as libc::c_ulong,
    ) as *mut uint32_t;
    if res.is_null() {
        return res;
    }
    let mut res1: *mut uint32_t = res;
    let mut res2: *mut uint32_t = res1;
    let mut bnLen: uint32_t = len
        .wrapping_sub(1 as libc::c_uint)
        .wrapping_div(4 as libc::c_uint)
        .wrapping_add(1 as libc::c_uint);
    let mut tmpLen: uint32_t = (4 as libc::c_uint).wrapping_mul(bnLen);
    if tmpLen as size_t
        > (18446744073709551615 as libc::c_ulong)
            .wrapping_div(::core::mem::size_of::<uint8_t>() as libc::c_ulong)
    {
        printf(
            b"Maximum allocatable size exceeded, aborting before overflow at %s:%d\n\0"
                as *const u8 as *const libc::c_char,
            b"Hacl_Bignum4096_32.c\0" as *const u8 as *const libc::c_char,
            1312 as libc::c_int,
        );
        exit(253 as libc::c_int);
    }
    let vla = tmpLen as usize;
    let mut tmp: Vec::<uint8_t> = ::std::vec::from_elem(0, vla);
    memset(
        tmp.as_mut_ptr() as *mut libc::c_void,
        0 as libc::c_uint as libc::c_int,
        (tmpLen as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint8_t>() as libc::c_ulong),
    );
    memcpy(
        tmp.as_mut_ptr() as *mut libc::c_void,
        b as *const libc::c_void,
        (len as libc::c_ulong)
            .wrapping_mul(::core::mem::size_of::<uint8_t>() as libc::c_ulong),
    );
    let mut i: uint32_t = 0 as libc::c_uint;
    while i
        < len
            .wrapping_sub(1 as libc::c_uint)
            .wrapping_div(4 as libc::c_uint)
            .wrapping_add(1 as libc::c_uint)
    {
        let mut bj: *mut uint8_t = tmp
            .as_mut_ptr()
            .offset(i.wrapping_mul(4 as libc::c_uint) as isize);
        let mut u: uint32_t = load32(bj);
        let mut r1: uint32_t = u;
        let mut x: uint32_t = r1;
        let mut os: *mut uint32_t = res2;
        *os.offset(i as isize) = x;
        i = i.wrapping_add(1);
        i;
    }
    return res2;
}
#[no_mangle]
pub unsafe extern "C" fn Hacl_Bignum4096_32_bn_to_bytes_be(
    mut b: *mut uint32_t,
    mut res: *mut uint8_t,
) {
    let mut tmp: [uint8_t; 512] = [
        0 as libc::c_uint as uint8_t,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    let mut i: uint32_t = 0 as libc::c_uint;
    while i < 128 as libc::c_uint {
        store32(
            res.offset(i.wrapping_mul(4 as libc::c_uint) as isize),
            if 0 != 0 {
                (*b
                    .offset(
                        (128 as libc::c_uint)
                            .wrapping_sub(i)
                            .wrapping_sub(1 as libc::c_uint) as isize,
                    ) & 0xff000000 as libc::c_uint) >> 24 as libc::c_int
                    | (*b
                        .offset(
                            (128 as libc::c_uint)
                                .wrapping_sub(i)
                                .wrapping_sub(1 as libc::c_uint) as isize,
                        ) & 0xff0000 as libc::c_uint) >> 8 as libc::c_int
                    | (*b
                        .offset(
                            (128 as libc::c_uint)
                                .wrapping_sub(i)
                                .wrapping_sub(1 as libc::c_uint) as isize,
                        ) & 0xff00 as libc::c_uint) << 8 as libc::c_int
                    | (*b
                        .offset(
                            (128 as libc::c_uint)
                                .wrapping_sub(i)
                                .wrapping_sub(1 as libc::c_uint) as isize,
                        ) & 0xff as libc::c_uint) << 24 as libc::c_int
            } else {
                _OSSwapInt32(
                    *b
                        .offset(
                            (128 as libc::c_uint)
                                .wrapping_sub(i)
                                .wrapping_sub(1 as libc::c_uint) as isize,
                        ),
                )
            },
        );
        i = i.wrapping_add(1);
        i;
    }
}
#[no_mangle]
pub unsafe extern "C" fn Hacl_Bignum4096_32_bn_to_bytes_le(
    mut b: *mut uint32_t,
    mut res: *mut uint8_t,
) {
    let mut tmp: [uint8_t; 512] = [
        0 as libc::c_uint as uint8_t,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ];
    let mut i: uint32_t = 0 as libc::c_uint;
    while i < 128 as libc::c_uint {
        store32(
            res.offset(i.wrapping_mul(4 as libc::c_uint) as isize),
            *b.offset(i as isize),
        );
        i = i.wrapping_add(1);
        i;
    }
}
#[no_mangle]
pub unsafe extern "C" fn Hacl_Bignum4096_32_lt_mask(
    mut a: *mut uint32_t,
    mut b: *mut uint32_t,
) -> uint32_t {
    let mut acc: uint32_t = 0 as libc::c_uint;
    let mut i: uint32_t = 0 as libc::c_uint;
    while i < 128 as libc::c_uint {
        let mut beq: uint32_t = FStar_UInt32_eq_mask(
            *a.offset(i as isize),
            *b.offset(i as isize),
        );
        let mut blt: uint32_t = !FStar_UInt32_gte_mask(
            *a.offset(i as isize),
            *b.offset(i as isize),
        );
        acc = beq & acc | !beq & blt;
        i = i.wrapping_add(1);
        i;
    }
    return acc;
}
#[no_mangle]
pub unsafe extern "C" fn Hacl_Bignum4096_32_eq_mask(
    mut a: *mut uint32_t,
    mut b: *mut uint32_t,
) -> uint32_t {
    let mut mask: uint32_t = 0xffffffff as libc::c_uint;
    let mut i: uint32_t = 0 as libc::c_uint;
    while i < 128 as libc::c_uint {
        let mut uu____0: uint32_t = FStar_UInt32_eq_mask(
            *a.offset(i as isize),
            *b.offset(i as isize),
        );
        mask = uu____0 & mask;
        i = i.wrapping_add(1);
        i;
    }
    let mut mask1: uint32_t = mask;
    return mask1;
}
